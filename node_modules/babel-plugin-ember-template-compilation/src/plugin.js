"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePlugin = void 0;
const babel_import_util_1 = require("babel-import-util");
const expression_parser_1 = require("./expression-parser");
const js_utils_1 = require("./js-utils");
const scope_locals_1 = require("./scope-locals");
const syntax_1 = require("@glimmer/syntax");
__exportStar(require("./public-types"), exports);
const INLINE_PRECOMPILE_MODULES = [
    {
        moduleName: 'ember-cli-htmlbars',
        export: 'hbs',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'ember-cli-htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: 'htmlbars-inline-precompile',
        export: 'default',
        allowTemplateLiteral: true,
    },
    {
        moduleName: '@ember/template-compilation',
        export: 'precompileTemplate',
        enableScope: true,
    },
    {
        moduleName: '@ember/template-compiler',
        export: 'template',
        enableScope: true,
        rfc931Support: 'polyfilled',
    },
];
function normalizeOpts(options) {
    var _a;
    if (((_a = options.targetFormat) !== null && _a !== void 0 ? _a : 'wire') === 'wire') {
        let { compiler } = options;
        if (!compiler) {
            throw new Error(`when targetFormat==="wire" you must set the compiler or compilerPath option`);
        }
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'wire', compiler });
    }
    else {
        return Object.assign(Object.assign({ outputModuleOverrides: {}, enableLegacyModules: [], transforms: [] }, options), { targetFormat: 'hbs' });
    }
}
function makePlugin(loadOptions) {
    return function htmlbarsInlinePrecompile(babel) {
        let t = babel.types;
        const plugin = {
            visitor: {
                Program: {
                    enter(path, state) {
                        state.normalizedOpts = normalizeOpts(loadOptions(state.opts));
                        state.templateFactory = templateFactoryConfig(state.normalizedOpts);
                        state.util = new babel_import_util_1.ImportUtil(babel, path);
                        state.program = path;
                        state.recursionGuard = new Set();
                    },
                    exit(_path, state) {
                        if (state.normalizedOpts.targetFormat === 'wire') {
                            for (let { moduleName, export: exportName } of configuredModules(state)) {
                                state.util.removeImport(moduleName, exportName);
                            }
                        }
                    },
                },
                TaggedTemplateExpression(path, state) {
                    let tagPath = path.get('tag');
                    if (!tagPath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(tagPath, state);
                    if (!config) {
                        return;
                    }
                    if (!config.allowTemplateLiteral) {
                        throw path.buildCodeFrameError(`Attempted to use \`${tagPath.node.name}\` as a template tag, but it can only be called as a function with a string passed to it: ${tagPath.node.name}('content here')`);
                    }
                    if (path.node.quasi.expressions.length) {
                        throw path.buildCodeFrameError('placeholders inside a tagged template string are not supported');
                    }
                    let template = path.node.quasi.quasis.map((quasi) => quasi.value.cooked).join('');
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, {}, config, undefined);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, {}, config, undefined);
                    }
                },
                CallExpression(path, state) {
                    let calleePath = path.get('callee');
                    if (!calleePath.isIdentifier()) {
                        return;
                    }
                    let config = referencesInlineCompiler(calleePath, state);
                    if (!config) {
                        return;
                    }
                    if (state.recursionGuard.has(path.node)) {
                        return;
                    }
                    if (path.get('arguments').length > 2) {
                        throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string and any static options`);
                    }
                    let [firstArg, secondArg] = path.get('arguments');
                    let template;
                    switch (firstArg === null || firstArg === void 0 ? void 0 : firstArg.node.type) {
                        case 'StringLiteral':
                            template = firstArg.node.value;
                            break;
                        case 'TemplateLiteral':
                            if (firstArg.node.expressions.length) {
                                throw path.buildCodeFrameError('placeholders inside a template string are not supported');
                            }
                            else {
                                template = firstArg.node.quasis.map((quasi) => quasi.value.cooked).join('');
                            }
                            break;
                        case 'TaggedTemplateExpression':
                            throw path.buildCodeFrameError(`tagged template strings inside ${calleePath.node.name} are not supported`);
                        default:
                            throw path.buildCodeFrameError(`${calleePath.node.name} should be invoked with at least a single argument (the template string)`);
                    }
                    let userTypedOptions;
                    let backingClass;
                    if (!secondArg) {
                        userTypedOptions = {};
                    }
                    else {
                        if (!secondArg.isObjectExpression()) {
                            throw path.buildCodeFrameError(`${calleePath.node.name} can only be invoked with 2 arguments: the template string, and any static options`);
                        }
                        userTypedOptions = new expression_parser_1.ExpressionParser(babel).parseObjectExpression(calleePath.node.name, secondArg, config.enableScope, Boolean(config.rfc931Support));
                        if (config.rfc931Support && userTypedOptions.component) {
                            backingClass = userTypedOptions.component;
                        }
                    }
                    if (state.normalizedOpts.targetFormat === 'wire') {
                        insertCompiledTemplate(babel, state, state.normalizedOpts, template, path, userTypedOptions, config, backingClass);
                    }
                    else {
                        insertTransformedTemplate(babel, state, template, path, userTypedOptions, config, backingClass);
                    }
                },
            },
        };
        return {
            pre(file) {
                // run our processing in pre so that imports for gts
                // are kept for other plugins.
                babel.traverse(file.ast, plugin.visitor, file.scope, this);
            },
            visitor: {},
        };
    };
}
exports.makePlugin = makePlugin;
function* configuredModules(state) {
    for (let moduleConfig of INLINE_PRECOMPILE_MODULES) {
        if (moduleConfig.moduleName !== '@ember/template-compilation' &&
            moduleConfig.moduleName !== '@ember/template-compiler' &&
            !state.normalizedOpts.enableLegacyModules.includes(moduleConfig.moduleName)) {
            continue;
        }
        yield moduleConfig;
    }
}
function referencesInlineCompiler(path, state) {
    for (let moduleConfig of configuredModules(state)) {
        if (path.referencesImport(moduleConfig.moduleName, moduleConfig.export)) {
            return moduleConfig;
        }
    }
    return undefined;
}
function runtimeErrorIIFE(babel, replacements) {
    let statement = babel.template(`(function() {\n  throw new Error('ERROR_MESSAGE');\n})();`)(replacements);
    return statement.expression;
}
function buildScopeLocals(userTypedOptions, formatOptions, target) {
    if (formatOptions.rfc931Support && userTypedOptions.eval) {
        return new scope_locals_1.ScopeLocals({ mode: 'implicit', jsPath: target });
    }
    else if (userTypedOptions.scope) {
        return userTypedOptions.scope;
    }
    else {
        return new scope_locals_1.ScopeLocals({ mode: 'explicit' });
    }
}
function buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scope) {
    let jsutils = new js_utils_1.JSUtils(babel, state, target, scope.add.bind(scope), state.util);
    let meta = Object.assign({ jsutils }, userTypedOptions === null || userTypedOptions === void 0 ? void 0 : userTypedOptions.meta);
    let output = {
        contents: template,
        // we've extended meta to add jsutils, but the types in @glimmer/syntax
        // don't account for extension
        meta: meta,
        // TODO: embroider's template-compiler allows this to be overriden to get
        // backward-compatible module names that don't match the real name of the
        // on-disk file. What's our plan for migrating people away from that?
        moduleName: state.filename,
        // This is here so it's *always* the real filename. Historically, there is
        // also `moduleName` but that did not match the real on-disk filename, it
        // was the notional runtime module name from classic ember builds.
        filename: state.filename,
        plugins: {
            // the cast is needed here only because our meta is extended. That is,
            // these plugins can access meta.jsutils.
            ast: [...state.normalizedOpts.transforms, scope.crawl()],
        },
    };
    for (let [key, value] of Object.entries(userTypedOptions)) {
        if (key !== 'scope') {
            // `scope` in the user-facing API becomes `locals` in the low-level
            // ember-template-compiler API
            output[key] = value;
        }
    }
    output.locals = scope.locals;
    if (config.rfc931Support) {
        output.strictMode = true;
    }
    return output;
}
function remapAndBindIdentifiers(target, babel, scopeLocals) {
    var _a;
    babel.traverse(target.node, {
        Identifier(path) {
            var _a;
            if (scopeLocals.has(path.node.name) && path.node.name !== scopeLocals.get(path.node.name)) {
                // this identifier has different names in hbs vs js, so we need to
                // replace the hbs name in the template compiler output with the js
                // name
                path.replaceWith(babel.types.identifier(scopeLocals.get(path.node.name)));
            }
            // this is where we tell babel's scope system about the new reference we
            // just introduced. @babel/plugin-transform-typescript in particular
            // cares a lot about those references being present.
            (_a = path.scope.getBinding(path.node.name)) === null || _a === void 0 ? void 0 : _a.reference(path);
        },
    }, target.scope, {}, (_a = target.parentPath) !== null && _a !== void 0 ? _a : undefined);
}
function insertCompiledTemplate(babel, state, opts, template, target, userTypedOptions, config, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, config, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, config, scopeLocals);
    let precompileResultString;
    // insertRuntimeErrors is legacy and not supported by the newer rfc931 form
    if (options.insertRuntimeErrors && !config.rfc931Support) {
        try {
            precompileResultString = opts.compiler.precompile(template, options);
        }
        catch (error) {
            target.replaceWith(runtimeErrorIIFE(babel, { ERROR_MESSAGE: error.message }));
            return;
        }
    }
    else {
        precompileResultString = opts.compiler.precompile(template, options);
    }
    let precompileResultAST = babel.parse(`var precompileResult = ${precompileResultString}; `, {
        babelrc: false,
        configFile: false,
    });
    let templateExpression = precompileResultAST.program.body[0]
        .declarations[0].init;
    t.addComment(templateExpression, 'leading', `\n  ${template.replace(/\*\//g, '*\\/')}\n`, 
    /* line comment? */ false);
    state.util.replaceWith(target, (i) => {
        var _a;
        let templateFactoryIdentifier = i.import(state.templateFactory.moduleName, state.templateFactory.exportName);
        let expression = t.callExpression(templateFactoryIdentifier, [templateExpression]);
        if (config.rfc931Support) {
            expression = t.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                expression,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : t.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        }
        return expression;
    });
    remapAndBindIdentifiers(target, babel, scopeLocals);
}
function insertTransformedTemplate(babel, state, template, target, userTypedOptions, formatOptions, backingClass) {
    let t = babel.types;
    let scopeLocals = buildScopeLocals(userTypedOptions, formatOptions, target);
    let options = buildPrecompileOptions(babel, target, state, template, userTypedOptions, formatOptions, scopeLocals);
    let ast = (0, syntax_1.preprocess)(template, Object.assign(Object.assign({}, options), { mode: 'codemod' }));
    let transformed = (0, syntax_1.print)(ast, { entityEncoding: 'raw' });
    if (target.isCallExpression()) {
        updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass);
    }
    else {
        updateBacktickForm(scopeLocals, state, target, t, transformed, babel);
    }
}
function updateBacktickForm(scopeLocals, state, target, t, transformed, babel) {
    if (scopeLocals.isEmpty()) {
        // simple case: just replace the string literal part with the transformed
        // template contents
        target.get('quasi').get('quasis.0').replaceWith(t.templateElement({ raw: transformed }));
        return;
    }
    // need to add scope, so need to replace the backticks form with a call
    // expression to precompileTemplate
    maybePruneImport(state.util, target.get('tag'));
    let newCall = state.util.replaceWith(target, (i) => t.callExpression(precompileTemplate(i), [t.stringLiteral(transformed)]));
    updateScope(babel, newCall, scopeLocals);
}
function updateCallForm(target, transformed, formatOptions, scopeLocals, state, babel, backingClass) {
    // first the simple part: replacing the string literal with the actual body of
    // the rewritten template
    target.get('arguments.0').replaceWith(babel.types.stringLiteral(transformed));
    if (!formatOptions.enableScope && !scopeLocals.isEmpty()) {
        // an AST transform added lexically scoped values to a template that
        // wasn't already in a form that supports them, so convert form.
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
    }
    if (formatOptions.rfc931Support === 'polyfilled') {
        maybePruneImport(state.util, target.get('callee'));
        state.util.replaceWith(target.get('callee'), (i) => precompileTemplate(i));
        convertStrictMode(babel, target);
        removeEvalAndScope(target);
        target.node.arguments = target.node.arguments.slice(0, 2);
        state.recursionGuard.add(target.node);
        state.util.replaceWith(target, (i) => {
            var _a;
            return babel.types.callExpression(i.import('@ember/component', 'setComponentTemplate'), [
                target.node,
                (_a = backingClass === null || backingClass === void 0 ? void 0 : backingClass.node) !== null && _a !== void 0 ? _a : babel.types.callExpression(i.import('@ember/component/template-only', 'default', 'templateOnly'), []),
            ]);
        });
        // we just wrapped the target callExpression in the call to
        // setComponentTemplate. Adjust `target` back to point at the
        // precompileTemplate call for the final updateScope below.
        //
        target = target.get('arguments.0');
    }
    // We deliberately do updateScope at the end so that when it updates
    // references, those references will point to the accurate paths in the
    // final AST.
    updateScope(babel, target, scopeLocals);
}
function templateFactoryConfig(opts) {
    var _a;
    let moduleName = '@ember/template-factory';
    let exportName = 'createTemplateFactory';
    let overrides = (_a = opts.outputModuleOverrides[moduleName]) === null || _a === void 0 ? void 0 : _a[exportName];
    return overrides
        ? { exportName: overrides[0], moduleName: overrides[1] }
        : { exportName, moduleName };
}
function buildScope(babel, locals) {
    let t = babel.types;
    return t.arrowFunctionExpression([], t.objectExpression(locals
        .entries()
        .map(([name, identifier]) => t.objectProperty(t.identifier(name), t.identifier(identifier), false, true))));
}
// this is responsible both for adjusting the AST for our scope argument *and*
// ensuring that babel's scope system will see that these new identifiers
// reference their bindings. @babel/plugin-transform-typescript in particular
// cares an awful lot about whether an import has valid non-type references, so
// these newly introducd references need to be valid.
function updateScope(babel, target, locals) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let scope = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'scope';
        });
        if (scope) {
            if (locals.isEmpty()) {
                scope.remove();
            }
            else {
                scope.set('value', buildScope(babel, locals));
                // funny-looking naming here, but it actually makes sense because we're
                // connecting the glimmer scope system with the babel scope system.
                scope.scope.crawl();
            }
        }
        else if (!locals.isEmpty()) {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('scope'), buildScope(babel, locals)));
            secondArg.get(`properties.${secondArg.node.properties.length - 1}`).scope.crawl();
        }
    }
    else if (!locals.isEmpty()) {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('scope'), buildScope(babel, locals))]));
        target.get('arguments.1').scope.crawl();
    }
}
function removeEvalAndScope(target) {
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let evalProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'eval';
        });
        if (evalProp) {
            evalProp.remove();
        }
        let componentProp = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'component';
        });
        if (componentProp) {
            componentProp.remove();
        }
    }
}
// Given a call to template(), convert its "strict" argument into
// precompileTemplate's "strictMode" argument. They differ in name and default
// value.
function convertStrictMode(babel, target) {
    let t = babel.types;
    let secondArg = target.get('arguments.1');
    if (secondArg) {
        let strict = secondArg.get('properties').find((p) => {
            let key = p.get('key');
            return key.isIdentifier() && key.node.name === 'strict';
        });
        if (strict) {
            strict.set('key', t.identifier('strictMode'));
        }
        else {
            secondArg.pushContainer('properties', t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true)));
        }
    }
    else {
        target.pushContainer('arguments', t.objectExpression([t.objectProperty(t.identifier('strictMode'), t.booleanLiteral(true))]));
    }
}
function maybePruneImport(util, identifier) {
    if (!identifier.isIdentifier()) {
        return;
    }
    let binding = identifier.scope.getBinding(identifier.node.name);
    // this checks if the identifier (that we're about to remove) is used in
    // exactly one place.
    if ((binding === null || binding === void 0 ? void 0 : binding.referencePaths.reduce((count, path) => (path.removed ? count : count + 1), 0)) === 1) {
        let specifier = binding.path;
        if (specifier.isImportSpecifier()) {
            let declaration = specifier.parentPath;
            util.removeImport(declaration.node.source.value, name(specifier.node.imported));
        }
    }
    identifier.removed = true;
}
function precompileTemplate(i) {
    return i.import('@ember/template-compilation', 'precompileTemplate');
}
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
exports.default = makePlugin((options) => options);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGx1Z2luLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGx1Z2luLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBR0EseURBQThEO0FBQzlELDJEQUF1RDtBQUN2RCx5Q0FBNEQ7QUFHNUQsaURBQTZDO0FBQzdDLDRDQUFzRTtBQUV0RSxpREFBK0I7QUFZL0IsTUFBTSx5QkFBeUIsR0FBbUI7SUFDaEQ7UUFDRSxVQUFVLEVBQUUsb0JBQW9CO1FBQ2hDLE1BQU0sRUFBRSxLQUFLO1FBQ2Isb0JBQW9CLEVBQUUsSUFBSTtLQUMzQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLHNDQUFzQztRQUNsRCxNQUFNLEVBQUUsU0FBUztRQUNqQixvQkFBb0IsRUFBRSxJQUFJO0tBQzNCO0lBQ0Q7UUFDRSxVQUFVLEVBQUUsNEJBQTRCO1FBQ3hDLE1BQU0sRUFBRSxTQUFTO1FBQ2pCLG9CQUFvQixFQUFFLElBQUk7S0FDM0I7SUFDRDtRQUNFLFVBQVUsRUFBRSw2QkFBNkI7UUFDekMsTUFBTSxFQUFFLG9CQUFvQjtRQUM1QixXQUFXLEVBQUUsSUFBSTtLQUNsQjtJQUNEO1FBQ0UsVUFBVSxFQUFFLDBCQUEwQjtRQUN0QyxNQUFNLEVBQUUsVUFBVTtRQUNsQixXQUFXLEVBQUUsSUFBSTtRQUNqQixhQUFhLEVBQUUsWUFBWTtLQUM1QjtDQUNGLENBQUM7QUErREYsU0FBUyxhQUFhLENBQUMsT0FBZ0I7O0lBQ3JDLElBQUksQ0FBQyxNQUFBLE9BQU8sQ0FBQyxZQUFZLG1DQUFJLE1BQU0sQ0FBQyxLQUFLLE1BQU0sRUFBRTtRQUMvQyxJQUFJLEVBQUUsUUFBUSxFQUFFLEdBQUcsT0FBTyxDQUFDO1FBQzNCLElBQUksQ0FBQyxRQUFRLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUNiLDZFQUE2RSxDQUM5RSxDQUFDO1NBQ0g7UUFDRCxxQ0FDRSxxQkFBcUIsRUFBRSxFQUFFLEVBQ3pCLG1CQUFtQixFQUFFLEVBQUUsRUFDdkIsVUFBVSxF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QUFPLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNsQjtBQUNILENBQUM7QUFFRCxrQkFBZSxVQUFVLENBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHR5cGUgeyBOb2RlUGF0aCB9IGZyb20gJ0BiYWJlbC90cmF2ZXJzZSc7XG5pbXBvcnQgdHlwZSAqIGFzIEJhYmVsIGZyb20gJ0BiYWJlbC9jb3JlJztcbmltcG9ydCB0eXBlIHsgdHlwZXMgYXMgdCB9IGZyb20gJ0BiYWJlbC9jb3JlJztcbmltcG9ydCB7IEltcG9ydFV0aWwsIHR5cGUgSW1wb3J0ZXIgfSBmcm9tICdiYWJlbC1pbXBvcnQtdXRpbCc7XG5pbXBvcnQgeyBFeHByZXNzaW9uUGFyc2VyIH0gZnJvbSAnLi9leHByZXNzaW9uLXBhcnNlcic7XG5pbXBvcnQgeyBKU1V0aWxzLCBFeHRlbmRlZFBsdWdpbkJ1aWxkZXIgfSBmcm9tICcuL2pzLXV0aWxzJztcbmltcG9ydCB0eXBlIHsgRW1iZXJUZW1wbGF0ZUNvbXBpbGVyLCBQcmVwcm9jZXNzT3B0aW9ucyB9IGZyb20gJy4vZW1iZXItdGVtcGxhdGUtY29tcGlsZXInO1xuaW1wb3J0IHsgTGVnYWN5TW9kdWxlTmFtZSB9IGZyb20gJy4vcHVibGljLXR5cGVzJztcbmltcG9ydCB7IFNjb3BlTG9jYWxzIH0gZnJvbSAnLi9zY29wZS1sb2NhbHMnO1xuaW1wb3J0IHsgQVNUUGx1Z2luQnVpbGRlciwgcHJlcHJvY2VzcywgcHJpbnQgfSBmcm9tICdAZ2xpbW1lci9zeW50YXgnO1xuXG5leHBvcnQgKiBmcm9tICcuL3B1YmxpYy10eXBlcyc7XG5cbnR5cGUgTW9kdWxlTmFtZSA9IExlZ2FjeU1vZHVsZU5hbWUgfCAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJyB8ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsZXInO1xuXG5pbnRlcmZhY2UgTW9kdWxlQ29uZmlnIHtcbiAgbW9kdWxlTmFtZTogTW9kdWxlTmFtZTtcbiAgZXhwb3J0OiBzdHJpbmc7XG4gIGFsbG93VGVtcGxhdGVMaXRlcmFsPzogdHJ1ZTtcbiAgZW5hYmxlU2NvcGU/OiB0cnVlO1xuICByZmM5MzFTdXBwb3J0PzogJ3BvbHlmaWxsZWQnO1xufVxuXG5jb25zdCBJTkxJTkVfUFJFQ09NUElMRV9NT0RVTEVTOiBNb2R1bGVDb25maWdbXSA9IFtcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdlbWJlci1jbGktaHRtbGJhcnMnLFxuICAgIGV4cG9ydDogJ2hicycsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnZW1iZXItY2xpLWh0bWxiYXJzLWlubGluZS1wcmVjb21waWxlJyxcbiAgICBleHBvcnQ6ICdkZWZhdWx0JyxcbiAgICBhbGxvd1RlbXBsYXRlTGl0ZXJhbDogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIG1vZHVsZU5hbWU6ICdodG1sYmFycy1pbmxpbmUtcHJlY29tcGlsZScsXG4gICAgZXhwb3J0OiAnZGVmYXVsdCcsXG4gICAgYWxsb3dUZW1wbGF0ZUxpdGVyYWw6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBtb2R1bGVOYW1lOiAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJyxcbiAgICBleHBvcnQ6ICdwcmVjb21waWxlVGVtcGxhdGUnLFxuICAgIGVuYWJsZVNjb3BlOiB0cnVlLFxuICB9LFxuICB7XG4gICAgbW9kdWxlTmFtZTogJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxlcicsXG4gICAgZXhwb3J0OiAndGVtcGxhdGUnLFxuICAgIGVuYWJsZVNjb3BlOiB0cnVlLFxuICAgIHJmYzkzMVN1cHBvcnQ6ICdwb2x5ZmlsbGVkJyxcbiAgfSxcbl07XG5cbmV4cG9ydCBpbnRlcmZhY2UgT3B0aW9ucyB7XG4gIC8vIFRoZSBlbWJlci10ZW1wbGF0ZS1jb21waWxlci5qcyBtb2R1bGUgdGhhdCBzaGlwcyB3aXRoaW4geW91ciBlbWJlci1zb3VyY2VcbiAgLy8gdmVyc2lvbi4gTWFuZGF0b3J5IHdoZW4gdXNpbmcgdGFyZ2V0Rm9ybWF0OiAnd2lyZScuXG4gIGNvbXBpbGVyPzogRW1iZXJUZW1wbGF0ZUNvbXBpbGVyO1xuXG4gIC8vIEFsbG93cyB5b3UgdG8gcmVtYXAgd2hhdCBpbXBvcnRzIHdpbGwgYmUgZW1pdHRlZCBpbiBvdXIgY29tcGlsZWQgb3V0cHV0LiBCeVxuICAvLyBleGFtcGxlOlxuICAvL1xuICAvLyAgIG91dHB1dE1vZHVsZU92ZXJyaWRlczoge1xuICAvLyAgICAgJ0BlbWJlci90ZW1wbGF0ZS1mYWN0b3J5Jzoge1xuICAvLyAgICAgICBjcmVhdGVUZW1wbGF0ZUZhY3Rvcnk6IFsnY3JlYXRlVGVtcGxhdGVGYWN0b3J5JywgJ0BnbGltbWVyL2NvcmUnXSxcbiAgLy8gICAgIH1cbiAgLy8gICB9XG4gIC8vXG4gIC8vIE5vcm1hbCBFbWJlciBhcHBzIHNob3VsZG4ndCBuZWVkIHRoaXMsIGl0IGV4aXN0cyB0byBzdXBwb3J0IG90aGVyXG4gIC8vIGVudmlyb25tZW50cyBsaWtlIHN0YW5kYWxvbmUgR2xpbW1lckpTXG4gIG91dHB1dE1vZHVsZU92ZXJyaWRlcz86IFJlY29yZDxzdHJpbmcsIFJlY29yZDxzdHJpbmcsIFtzdHJpbmcsIHN0cmluZ10+PjtcblxuICAvLyBCeSBkZWZhdWx0LCB0aGlzIHBsdWdpbiBpbXBsZW1lbnRzIG9ubHkgRW1iZXIncyBzdGFibGUgcHVibGljIEFQSSBmb3JcbiAgLy8gdGVtcGxhdGUgY29tcGlsYXRpb24sIHdoaWNoIGlzOlxuICAvL1xuICAvLyAgICBpbXBvcnQgeyBwcmVjb21waWxlVGVtcGxhdGUgfSBmcm9tICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsYXRpb24nO1xuICAvL1xuICAvLyBCdXQgaGlzdG9yaWNhbGx5IHRoZXJlIGFyZSBzZXZlcmFsIG90aGVyIGltcG9ydGFibGUgc3ludGF4ZXMgaW4gd2lkZXNwcmVhZFxuICAvLyB1c2UsIGFuZCB3ZSBjYW4gZW5hYmxlIHRob3NlIHRvbyBieSBpbmNsdWRpbmcgdGhlaXIgbW9kdWxlIG5hbWVzIGluIHRoaXNcbiAgLy8gbGlzdC5cbiAgZW5hYmxlTGVnYWN5TW9kdWxlcz86IExlZ2FjeU1vZHVsZU5hbWVbXTtcblxuICAvLyBDb250cm9scyB0aGUgb3V0cHV0IGZvcm1hdC5cbiAgLy9cbiAgLy8gIFwid2lyZVwiOiBUaGUgZGVmYXVsdC4gSW4gdGhlIG91dHB1dCwgeW91ciB0ZW1wbGF0ZXMgYXJlIHJlYWR5IHRvIGV4ZWN1dGUgaW5cbiAgLy8gIHRoZSBtb3N0IHBlcmZvcm1hbnQgd2F5LlxuICAvL1xuICAvLyAgXCJoYnNcIjogSW4gdGhlIG91dHB1dCwgeW91ciB0ZW1wbGF0ZXMgd2lsbCBzdGlsbCBiZSBpbiBIQlMgZm9ybWF0LlxuICAvLyAgR2VuZXJhbGx5IHRoaXMgbWVhbnMgdGhleSB3aWxsIHN0aWxsIG5lZWQgZnVydGhlciBwcm9jZXNzaW5nIGJlZm9yZVxuICAvLyAgdGhleSdyZSByZWFkeSB0byBleGVjdXRlLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1vZGUgaXMgdG8gc3VwcG9ydCB0aGluZ3NcbiAgLy8gIGxpa2UgY29kZW1vZHMgYW5kIHByZS1wdWJsaWNhdGlvbiB0cmFuc2Zvcm1hdGlvbnMgaW4gbGlicmFyaWVzLlxuICB0YXJnZXRGb3JtYXQ/OiAnd2lyZScgfCAnaGJzJztcblxuICAvLyBPcHRpb25hbCBsaXN0IG9mIGN1c3RvbSB0cmFuc2Zvcm1zIHRvIGFwcGx5IHRvIHRoZSBoYW5kbGViYXJzIEFTVCBiZWZvcmVcbiAgLy8gY29tcGlsYXRpb24uXG4gIHRyYW5zZm9ybXM/OiBFeHRlbmRlZFBsdWdpbkJ1aWxkZXJbXTtcbn1cblxuaW50ZXJmYWNlIFdpcmVPcHRzIHtcbiAgdGFyZ2V0Rm9ybWF0OiAnd2lyZSc7XG4gIGNvbXBpbGVyOiBFbWJlclRlbXBsYXRlQ29tcGlsZXI7XG4gIG91dHB1dE1vZHVsZU92ZXJyaWRlczogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuICBlbmFibGVMZWdhY3lNb2R1bGVzOiBMZWdhY3lNb2R1bGVOYW1lW107XG4gIHRyYW5zZm9ybXM6IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG5pbnRlcmZhY2UgSGJzT3B0cyB7XG4gIHRhcmdldEZvcm1hdDogJ2hicyc7XG4gIG91dHB1dE1vZHVsZU92ZXJyaWRlczogUmVjb3JkPHN0cmluZywgUmVjb3JkPHN0cmluZywgW3N0cmluZywgc3RyaW5nXT4+O1xuICBlbmFibGVMZWdhY3lNb2R1bGVzOiBMZWdhY3lNb2R1bGVOYW1lW107XG4gIHRyYW5zZm9ybXM6IEV4dGVuZGVkUGx1Z2luQnVpbGRlcltdO1xufVxuXG50eXBlIE5vcm1hbGl6ZWRPcHRzID0gV2lyZU9wdHMgfCBIYnNPcHRzO1xuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRzKG9wdGlvbnM6IE9wdGlvbnMpOiBOb3JtYWxpemVkT3B0cyB7XG4gIGlmICgob3B0aW9ucy50YXJnZXRGb3JtYXQgPz8gJ3dpcmUnKSA9PT0gJ3dpcmUnKSB7XG4gICAgbGV0IHsgY29tcGlsZXIgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCFjb21waWxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgd2hlbiB0YXJnZXRGb3JtYXQ9PT1cIndpcmVcIiB5b3UgbXVzdCBzZXQgdGhlIGNvbXBpbGVyIG9yIGNvbXBpbGVyUGF0aCBvcHRpb25gXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0cHV0TW9kdWxlT3ZlcnJpZGVzOiB7fSxcbiAgICAgIGVuYWJsZUxlZ2FjeU1vZHVsZXM6IFtdLFxuICAgICAgdHJhbnNmb3JtczogW10sXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgdGFyZ2V0Rm9ybWF0OiAnd2lyZScsXG4gICAgICBjb21waWxlcixcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICBvdXRwdXRNb2R1bGVPdmVycmlkZXM6IHt9LFxuICAgICAgZW5hYmxlTGVnYWN5TW9kdWxlczogW10sXG4gICAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICB0YXJnZXRGb3JtYXQ6ICdoYnMnLFxuICAgIH07XG4gIH1cbn1cblxuaW50ZXJmYWNlIFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4ge1xuICBvcHRzOiBFbnZTcGVjaWZpY09wdGlvbnM7XG4gIG5vcm1hbGl6ZWRPcHRzOiBOb3JtYWxpemVkT3B0cztcbiAgdXRpbDogSW1wb3J0VXRpbDtcbiAgdGVtcGxhdGVGYWN0b3J5OiB7IG1vZHVsZU5hbWU6IHN0cmluZzsgZXhwb3J0TmFtZTogc3RyaW5nIH07XG4gIHByb2dyYW06IE5vZGVQYXRoPHQuUHJvZ3JhbT47XG4gIGxhc3RJbnNlcnRlZFBhdGg6IE5vZGVQYXRoPHQuU3RhdGVtZW50PiB8IHVuZGVmaW5lZDtcbiAgZmlsZW5hbWU6IHN0cmluZztcbiAgcmVjdXJzaW9uR3VhcmQ6IFNldDx1bmtub3duPjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VQbHVnaW48RW52U3BlY2lmaWNPcHRpb25zPihsb2FkT3B0aW9uczogKG9wdHM6IEVudlNwZWNpZmljT3B0aW9ucykgPT4gT3B0aW9ucykge1xuICByZXR1cm4gZnVuY3Rpb24gaHRtbGJhcnNJbmxpbmVQcmVjb21waWxlKFxuICAgIGJhYmVsOiB0eXBlb2YgQmFiZWxcbiAgKTogQmFiZWwuUGx1Z2luT2JqPFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4+IHtcbiAgICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuXG4gICAgY29uc3QgcGx1Z2luID0ge1xuICAgICAgdmlzaXRvcjoge1xuICAgICAgICBQcm9ncmFtOiB7XG4gICAgICAgICAgZW50ZXIocGF0aDogTm9kZVBhdGg8dC5Qcm9ncmFtPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRPcHRzID0gbm9ybWFsaXplT3B0cyhsb2FkT3B0aW9ucyhzdGF0ZS5vcHRzKSk7XG4gICAgICAgICAgICBzdGF0ZS50ZW1wbGF0ZUZhY3RvcnkgPSB0ZW1wbGF0ZUZhY3RvcnlDb25maWcoc3RhdGUubm9ybWFsaXplZE9wdHMpO1xuICAgICAgICAgICAgc3RhdGUudXRpbCA9IG5ldyBJbXBvcnRVdGlsKGJhYmVsLCBwYXRoKTtcbiAgICAgICAgICAgIHN0YXRlLnByb2dyYW0gPSBwYXRoO1xuICAgICAgICAgICAgc3RhdGUucmVjdXJzaW9uR3VhcmQgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBleGl0KF9wYXRoOiBOb2RlUGF0aDx0LlByb2dyYW0+LCBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICAgICAgICAgICAgaWYgKHN0YXRlLm5vcm1hbGl6ZWRPcHRzLnRhcmdldEZvcm1hdCA9PT0gJ3dpcmUnKSB7XG4gICAgICAgICAgICAgIGZvciAobGV0IHsgbW9kdWxlTmFtZSwgZXhwb3J0OiBleHBvcnROYW1lIH0gb2YgY29uZmlndXJlZE1vZHVsZXMoc3RhdGUpKSB7XG4gICAgICAgICAgICAgICAgc3RhdGUudXRpbC5yZW1vdmVJbXBvcnQobW9kdWxlTmFtZSwgZXhwb3J0TmFtZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuXG4gICAgICAgIFRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbihcbiAgICAgICAgICBwYXRoOiBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gICAgICAgICAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz5cbiAgICAgICAgKSB7XG4gICAgICAgICAgbGV0IHRhZ1BhdGggPSBwYXRoLmdldCgndGFnJyk7XG5cbiAgICAgICAgICBpZiAoIXRhZ1BhdGguaXNJZGVudGlmaWVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGV0IGNvbmZpZyA9IHJlZmVyZW5jZXNJbmxpbmVDb21waWxlcih0YWdQYXRoLCBzdGF0ZSk7XG4gICAgICAgICAgaWYgKCFjb25maWcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIWNvbmZpZy5hbGxvd1RlbXBsYXRlTGl0ZXJhbCkge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICBgQXR0ZW1wdGVkIHRvIHVzZSBcXGAke3RhZ1BhdGgubm9kZS5uYW1lfVxcYCBhcyBhIHRlbXBsYXRlIHRhZywgYnV0IGl0IGNhbiBvbmx5IGJlIGNhbGxlZCBhcyBhIGZ1bmN0aW9uIHdpdGggYSBzdHJpbmcgcGFzc2VkIHRvIGl0OiAke3RhZ1BhdGgubm9kZS5uYW1lfSgnY29udGVudCBoZXJlJylgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoLm5vZGUucXVhc2kuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICdwbGFjZWhvbGRlcnMgaW5zaWRlIGEgdGFnZ2VkIHRlbXBsYXRlIHN0cmluZyBhcmUgbm90IHN1cHBvcnRlZCdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHRlbXBsYXRlID0gcGF0aC5ub2RlLnF1YXNpLnF1YXNpcy5tYXAoKHF1YXNpKSA9PiBxdWFzaS52YWx1ZS5jb29rZWQpLmpvaW4oJycpO1xuICAgICAgICAgIGlmIChzdGF0ZS5ub3JtYWxpemVkT3B0cy50YXJnZXRGb3JtYXQgPT09ICd3aXJlJykge1xuICAgICAgICAgICAgaW5zZXJ0Q29tcGlsZWRUZW1wbGF0ZShcbiAgICAgICAgICAgICAgYmFiZWwsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkT3B0cyxcbiAgICAgICAgICAgICAgdGVtcGxhdGUsXG4gICAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICAgIHt9LFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIHVuZGVmaW5lZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0VHJhbnNmb3JtZWRUZW1wbGF0ZShiYWJlbCwgc3RhdGUsIHRlbXBsYXRlLCBwYXRoLCB7fSwgY29uZmlnLCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBDYWxsRXhwcmVzc2lvbihwYXRoOiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPiwgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4pIHtcbiAgICAgICAgICBsZXQgY2FsbGVlUGF0aCA9IHBhdGguZ2V0KCdjYWxsZWUnKTtcblxuICAgICAgICAgIGlmICghY2FsbGVlUGF0aC5pc0lkZW50aWZpZXIoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsZXQgY29uZmlnID0gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyKGNhbGxlZVBhdGgsIHN0YXRlKTtcbiAgICAgICAgICBpZiAoIWNvbmZpZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChzdGF0ZS5yZWN1cnNpb25HdWFyZC5oYXMocGF0aC5ub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChwYXRoLmdldCgnYXJndW1lbnRzJykubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gY2FuIG9ubHkgYmUgaW52b2tlZCB3aXRoIDIgYXJndW1lbnRzOiB0aGUgdGVtcGxhdGUgc3RyaW5nIGFuZCBhbnkgc3RhdGljIG9wdGlvbnNgXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxldCBbZmlyc3RBcmcsIHNlY29uZEFyZ10gPSBwYXRoLmdldCgnYXJndW1lbnRzJyk7XG5cbiAgICAgICAgICBsZXQgdGVtcGxhdGU7XG5cbiAgICAgICAgICBzd2l0Y2ggKGZpcnN0QXJnPy5ub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZpcnN0QXJnLm5vZGUudmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGVtcGxhdGVMaXRlcmFsJzpcbiAgICAgICAgICAgICAgaWYgKGZpcnN0QXJnLm5vZGUuZXhwcmVzc2lvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgICAgJ3BsYWNlaG9sZGVycyBpbnNpZGUgYSB0ZW1wbGF0ZSBzdHJpbmcgYXJlIG5vdCBzdXBwb3J0ZWQnXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZSA9IGZpcnN0QXJnLm5vZGUucXVhc2lzLm1hcCgocXVhc2kpID0+IHF1YXNpLnZhbHVlLmNvb2tlZCkuam9pbignJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb24nOlxuICAgICAgICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICAgICAgYHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmdzIGluc2lkZSAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBhcmUgbm90IHN1cHBvcnRlZGBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICAgICAgICBgJHtjYWxsZWVQYXRoLm5vZGUubmFtZX0gc2hvdWxkIGJlIGludm9rZWQgd2l0aCBhdCBsZWFzdCBhIHNpbmdsZSBhcmd1bWVudCAodGhlIHRlbXBsYXRlIHN0cmluZylgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGV0IHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgICAgICAgIGxldCBiYWNraW5nQ2xhc3M6IHVuZGVmaW5lZCB8IE5vZGVQYXRoPFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl0+O1xuXG4gICAgICAgICAgaWYgKCFzZWNvbmRBcmcpIHtcbiAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFzZWNvbmRBcmcuaXNPYmplY3RFeHByZXNzaW9uKCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgICAgICAgIGAke2NhbGxlZVBhdGgubm9kZS5uYW1lfSBjYW4gb25seSBiZSBpbnZva2VkIHdpdGggMiBhcmd1bWVudHM6IHRoZSB0ZW1wbGF0ZSBzdHJpbmcsIGFuZCBhbnkgc3RhdGljIG9wdGlvbnNgXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVzZXJUeXBlZE9wdGlvbnMgPSBuZXcgRXhwcmVzc2lvblBhcnNlcihiYWJlbCkucGFyc2VPYmplY3RFeHByZXNzaW9uKFxuICAgICAgICAgICAgICBjYWxsZWVQYXRoLm5vZGUubmFtZSxcbiAgICAgICAgICAgICAgc2Vjb25kQXJnLFxuICAgICAgICAgICAgICBjb25maWcuZW5hYmxlU2NvcGUsXG4gICAgICAgICAgICAgIEJvb2xlYW4oY29uZmlnLnJmYzkzMVN1cHBvcnQpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgaWYgKGNvbmZpZy5yZmM5MzFTdXBwb3J0ICYmIHVzZXJUeXBlZE9wdGlvbnMuY29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIGJhY2tpbmdDbGFzcyA9IHVzZXJUeXBlZE9wdGlvbnMuY29tcG9uZW50IGFzIE5vZGVQYXRoPFxuICAgICAgICAgICAgICAgIFBhcmFtZXRlcnM8dHlwZW9mIHQuY2FsbEV4cHJlc3Npb24+WzFdW251bWJlcl1cbiAgICAgICAgICAgICAgPjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3RhdGUubm9ybWFsaXplZE9wdHMudGFyZ2V0Rm9ybWF0ID09PSAnd2lyZScpIHtcbiAgICAgICAgICAgIGluc2VydENvbXBpbGVkVGVtcGxhdGUoXG4gICAgICAgICAgICAgIGJhYmVsLFxuICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgc3RhdGUubm9ybWFsaXplZE9wdHMsXG4gICAgICAgICAgICAgIHRlbXBsYXRlLFxuICAgICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgICB1c2VyVHlwZWRPcHRpb25zLFxuICAgICAgICAgICAgICBjb25maWcsXG4gICAgICAgICAgICAgIGJhY2tpbmdDbGFzc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5zZXJ0VHJhbnNmb3JtZWRUZW1wbGF0ZShcbiAgICAgICAgICAgICAgYmFiZWwsXG4gICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICB0ZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICAgICAgICAgICAgY29uZmlnLFxuICAgICAgICAgICAgICBiYWNraW5nQ2xhc3NcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHByZSh0aGlzOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LCBmaWxlKSB7XG4gICAgICAgIC8vIHJ1biBvdXIgcHJvY2Vzc2luZyBpbiBwcmUgc28gdGhhdCBpbXBvcnRzIGZvciBndHNcbiAgICAgICAgLy8gYXJlIGtlcHQgZm9yIG90aGVyIHBsdWdpbnMuXG4gICAgICAgIGJhYmVsLnRyYXZlcnNlKGZpbGUuYXN0LCBwbHVnaW4udmlzaXRvciwgZmlsZS5zY29wZSwgdGhpcyk7XG4gICAgICB9LFxuICAgICAgdmlzaXRvcjoge30sXG4gICAgfTtcbiAgfSBhcyAoYmFiZWw6IHR5cGVvZiBCYWJlbCkgPT4gQmFiZWwuUGx1Z2luT2JqPHVua25vd24+O1xufVxuXG5mdW5jdGlvbiogY29uZmlndXJlZE1vZHVsZXM8RW52U3BlY2lmaWNPcHRpb25zPihzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPikge1xuICBmb3IgKGxldCBtb2R1bGVDb25maWcgb2YgSU5MSU5FX1BSRUNPTVBJTEVfTU9EVUxFUykge1xuICAgIGlmIChcbiAgICAgIG1vZHVsZUNvbmZpZy5tb2R1bGVOYW1lICE9PSAnQGVtYmVyL3RlbXBsYXRlLWNvbXBpbGF0aW9uJyAmJlxuICAgICAgbW9kdWxlQ29uZmlnLm1vZHVsZU5hbWUgIT09ICdAZW1iZXIvdGVtcGxhdGUtY29tcGlsZXInICYmXG4gICAgICAhc3RhdGUubm9ybWFsaXplZE9wdHMuZW5hYmxlTGVnYWN5TW9kdWxlcy5pbmNsdWRlcyhtb2R1bGVDb25maWcubW9kdWxlTmFtZSlcbiAgICApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB5aWVsZCBtb2R1bGVDb25maWc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVmZXJlbmNlc0lubGluZUNvbXBpbGVyPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIHBhdGg6IE5vZGVQYXRoPHQuSWRlbnRpZmllcj4sXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+XG4pOiBNb2R1bGVDb25maWcgfCB1bmRlZmluZWQge1xuICBmb3IgKGxldCBtb2R1bGVDb25maWcgb2YgY29uZmlndXJlZE1vZHVsZXMoc3RhdGUpKSB7XG4gICAgaWYgKHBhdGgucmVmZXJlbmNlc0ltcG9ydChtb2R1bGVDb25maWcubW9kdWxlTmFtZSwgbW9kdWxlQ29uZmlnLmV4cG9ydCkpIHtcbiAgICAgIHJldHVybiBtb2R1bGVDb25maWc7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHJ1bnRpbWVFcnJvcklJRkUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgcmVwbGFjZW1lbnRzOiB7IEVSUk9SX01FU1NBR0U6IHN0cmluZyB9KSB7XG4gIGxldCBzdGF0ZW1lbnQgPSBiYWJlbC50ZW1wbGF0ZShgKGZ1bmN0aW9uKCkge1xcbiAgdGhyb3cgbmV3IEVycm9yKCdFUlJPUl9NRVNTQUdFJyk7XFxufSkoKTtgKShcbiAgICByZXBsYWNlbWVudHNcbiAgKSBhcyB0LkV4cHJlc3Npb25TdGF0ZW1lbnQ7XG4gIHJldHVybiBzdGF0ZW1lbnQuZXhwcmVzc2lvbjtcbn1cblxuZnVuY3Rpb24gYnVpbGRTY29wZUxvY2FscyhcbiAgdXNlclR5cGVkT3B0aW9uczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4sXG4gIGZvcm1hdE9wdGlvbnM6IE1vZHVsZUNvbmZpZyxcbiAgdGFyZ2V0OiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+XG4pOiBTY29wZUxvY2FscyB7XG4gIGlmIChmb3JtYXRPcHRpb25zLnJmYzkzMVN1cHBvcnQgJiYgdXNlclR5cGVkT3B0aW9ucy5ldmFsKSB7XG4gICAgcmV0dXJuIG5ldyBTY29wZUxvY2Fscyh7IG1vZGU6ICdpbXBsaWNpdCcsIGpzUGF0aDogdGFyZ2V0IH0pO1xuICB9IGVsc2UgaWYgKHVzZXJUeXBlZE9wdGlvbnMuc2NvcGUpIHtcbiAgICByZXR1cm4gdXNlclR5cGVkT3B0aW9ucy5zY29wZSBhcyBTY29wZUxvY2FscztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IFNjb3BlTG9jYWxzKHsgbW9kZTogJ2V4cGxpY2l0JyB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBidWlsZFByZWNvbXBpbGVPcHRpb25zPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gIGJhYmVsOiB0eXBlb2YgQmFiZWwsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5FeHByZXNzaW9uPixcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIHRlbXBsYXRlOiBzdHJpbmcsXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb25maWc6IE1vZHVsZUNvbmZpZyxcbiAgc2NvcGU6IFNjb3BlTG9jYWxzXG4pOiBQcmVwcm9jZXNzT3B0aW9ucyAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgbGV0IGpzdXRpbHMgPSBuZXcgSlNVdGlscyhiYWJlbCwgc3RhdGUsIHRhcmdldCwgc2NvcGUuYWRkLmJpbmQoc2NvcGUpLCBzdGF0ZS51dGlsKTtcbiAgbGV0IG1ldGEgPSBPYmplY3QuYXNzaWduKHsganN1dGlscyB9LCB1c2VyVHlwZWRPcHRpb25zPy5tZXRhKTtcblxuICBsZXQgb3V0cHV0OiBQcmVwcm9jZXNzT3B0aW9ucyAmIFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge1xuICAgIGNvbnRlbnRzOiB0ZW1wbGF0ZSxcblxuICAgIC8vIHdlJ3ZlIGV4dGVuZGVkIG1ldGEgdG8gYWRkIGpzdXRpbHMsIGJ1dCB0aGUgdHlwZXMgaW4gQGdsaW1tZXIvc3ludGF4XG4gICAgLy8gZG9uJ3QgYWNjb3VudCBmb3IgZXh0ZW5zaW9uXG4gICAgbWV0YTogbWV0YSBhcyBQcmVwcm9jZXNzT3B0aW9uc1snbWV0YSddLFxuXG4gICAgLy8gVE9ETzogZW1icm9pZGVyJ3MgdGVtcGxhdGUtY29tcGlsZXIgYWxsb3dzIHRoaXMgdG8gYmUgb3ZlcnJpZGVuIHRvIGdldFxuICAgIC8vIGJhY2t3YXJkLWNvbXBhdGlibGUgbW9kdWxlIG5hbWVzIHRoYXQgZG9uJ3QgbWF0Y2ggdGhlIHJlYWwgbmFtZSBvZiB0aGVcbiAgICAvLyBvbi1kaXNrIGZpbGUuIFdoYXQncyBvdXIgcGxhbiBmb3IgbWlncmF0aW5nIHBlb3BsZSBhd2F5IGZyb20gdGhhdD9cbiAgICBtb2R1bGVOYW1lOiBzdGF0ZS5maWxlbmFtZSxcblxuICAgIC8vIFRoaXMgaXMgaGVyZSBzbyBpdCdzICphbHdheXMqIHRoZSByZWFsIGZpbGVuYW1lLiBIaXN0b3JpY2FsbHksIHRoZXJlIGlzXG4gICAgLy8gYWxzbyBgbW9kdWxlTmFtZWAgYnV0IHRoYXQgZGlkIG5vdCBtYXRjaCB0aGUgcmVhbCBvbi1kaXNrIGZpbGVuYW1lLCBpdFxuICAgIC8vIHdhcyB0aGUgbm90aW9uYWwgcnVudGltZSBtb2R1bGUgbmFtZSBmcm9tIGNsYXNzaWMgZW1iZXIgYnVpbGRzLlxuICAgIGZpbGVuYW1lOiBzdGF0ZS5maWxlbmFtZSxcblxuICAgIHBsdWdpbnM6IHtcbiAgICAgIC8vIHRoZSBjYXN0IGlzIG5lZWRlZCBoZXJlIG9ubHkgYmVjYXVzZSBvdXIgbWV0YSBpcyBleHRlbmRlZC4gVGhhdCBpcyxcbiAgICAgIC8vIHRoZXNlIHBsdWdpbnMgY2FuIGFjY2VzcyBtZXRhLmpzdXRpbHMuXG4gICAgICBhc3Q6IFsuLi5zdGF0ZS5ub3JtYWxpemVkT3B0cy50cmFuc2Zvcm1zLCBzY29wZS5jcmF3bCgpXSBhcyBBU1RQbHVnaW5CdWlsZGVyW10sXG4gICAgfSxcbiAgfTtcblxuICBmb3IgKGxldCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModXNlclR5cGVkT3B0aW9ucykpIHtcbiAgICBpZiAoa2V5ICE9PSAnc2NvcGUnKSB7XG4gICAgICAvLyBgc2NvcGVgIGluIHRoZSB1c2VyLWZhY2luZyBBUEkgYmVjb21lcyBgbG9jYWxzYCBpbiB0aGUgbG93LWxldmVsXG4gICAgICAvLyBlbWJlci10ZW1wbGF0ZS1jb21waWxlciBBUElcbiAgICAgIG91dHB1dFtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgb3V0cHV0LmxvY2FscyA9IHNjb3BlLmxvY2FscztcblxuICBpZiAoY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICBvdXRwdXQuc3RyaWN0TW9kZSA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuXG5mdW5jdGlvbiByZW1hcEFuZEJpbmRJZGVudGlmaWVycyh0YXJnZXQ6IE5vZGVQYXRoLCBiYWJlbDogdHlwZW9mIEJhYmVsLCBzY29wZUxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgYmFiZWwudHJhdmVyc2UoXG4gICAgdGFyZ2V0Lm5vZGUsXG4gICAge1xuICAgICAgSWRlbnRpZmllcihwYXRoOiBOb2RlUGF0aDx0LklkZW50aWZpZXI+KSB7XG4gICAgICAgIGlmIChzY29wZUxvY2Fscy5oYXMocGF0aC5ub2RlLm5hbWUpICYmIHBhdGgubm9kZS5uYW1lICE9PSBzY29wZUxvY2Fscy5nZXQocGF0aC5ub2RlLm5hbWUpKSB7XG4gICAgICAgICAgLy8gdGhpcyBpZGVudGlmaWVyIGhhcyBkaWZmZXJlbnQgbmFtZXMgaW4gaGJzIHZzIGpzLCBzbyB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gcmVwbGFjZSB0aGUgaGJzIG5hbWUgaW4gdGhlIHRlbXBsYXRlIGNvbXBpbGVyIG91dHB1dCB3aXRoIHRoZSBqc1xuICAgICAgICAgIC8vIG5hbWVcbiAgICAgICAgICBwYXRoLnJlcGxhY2VXaXRoKGJhYmVsLnR5cGVzLmlkZW50aWZpZXIoc2NvcGVMb2NhbHMuZ2V0KHBhdGgubm9kZS5uYW1lKSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMgaXMgd2hlcmUgd2UgdGVsbCBiYWJlbCdzIHNjb3BlIHN5c3RlbSBhYm91dCB0aGUgbmV3IHJlZmVyZW5jZSB3ZVxuICAgICAgICAvLyBqdXN0IGludHJvZHVjZWQuIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXR5cGVzY3JpcHQgaW4gcGFydGljdWxhclxuICAgICAgICAvLyBjYXJlcyBhIGxvdCBhYm91dCB0aG9zZSByZWZlcmVuY2VzIGJlaW5nIHByZXNlbnQuXG4gICAgICAgIHBhdGguc2NvcGUuZ2V0QmluZGluZyhwYXRoLm5vZGUubmFtZSk/LnJlZmVyZW5jZShwYXRoKTtcbiAgICAgIH0sXG4gICAgfSxcbiAgICB0YXJnZXQuc2NvcGUsXG4gICAge30sXG4gICAgdGFyZ2V0LnBhcmVudFBhdGggPz8gdW5kZWZpbmVkXG4gICk7XG59XG5cbmZ1bmN0aW9uIGluc2VydENvbXBpbGVkVGVtcGxhdGU8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIG9wdHM6IFdpcmVPcHRzLFxuICB0ZW1wbGF0ZTogc3RyaW5nLFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbj4sXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBjb25maWc6IE1vZHVsZUNvbmZpZyxcbiAgYmFja2luZ0NsYXNzOiBOb2RlUGF0aDxQYXJhbWV0ZXJzPHR5cGVvZiB0LmNhbGxFeHByZXNzaW9uPlsxXVtudW1iZXJdPiB8IHVuZGVmaW5lZFxuKSB7XG4gIGxldCB0ID0gYmFiZWwudHlwZXM7XG4gIGxldCBzY29wZUxvY2FscyA9IGJ1aWxkU2NvcGVMb2NhbHModXNlclR5cGVkT3B0aW9ucywgY29uZmlnLCB0YXJnZXQpO1xuICBsZXQgb3B0aW9ucyA9IGJ1aWxkUHJlY29tcGlsZU9wdGlvbnMoXG4gICAgYmFiZWwsXG4gICAgdGFyZ2V0LFxuICAgIHN0YXRlLFxuICAgIHRlbXBsYXRlLFxuICAgIHVzZXJUeXBlZE9wdGlvbnMsXG4gICAgY29uZmlnLFxuICAgIHNjb3BlTG9jYWxzXG4gICk7XG5cbiAgbGV0IHByZWNvbXBpbGVSZXN1bHRTdHJpbmc6IHN0cmluZztcblxuICAvLyBpbnNlcnRSdW50aW1lRXJyb3JzIGlzIGxlZ2FjeSBhbmQgbm90IHN1cHBvcnRlZCBieSB0aGUgbmV3ZXIgcmZjOTMxIGZvcm1cbiAgaWYgKG9wdGlvbnMuaW5zZXJ0UnVudGltZUVycm9ycyAmJiAhY29uZmlnLnJmYzkzMVN1cHBvcnQpIHtcbiAgICB0cnkge1xuICAgICAgcHJlY29tcGlsZVJlc3VsdFN0cmluZyA9IG9wdHMuY29tcGlsZXIucHJlY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRhcmdldC5yZXBsYWNlV2l0aChydW50aW1lRXJyb3JJSUZFKGJhYmVsLCB7IEVSUk9SX01FU1NBR0U6IChlcnJvciBhcyBhbnkpLm1lc3NhZ2UgfSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcmVjb21waWxlUmVzdWx0U3RyaW5nID0gb3B0cy5jb21waWxlci5wcmVjb21waWxlKHRlbXBsYXRlLCBvcHRpb25zKTtcbiAgfVxuXG4gIGxldCBwcmVjb21waWxlUmVzdWx0QVNUID0gYmFiZWwucGFyc2UoYHZhciBwcmVjb21waWxlUmVzdWx0ID0gJHtwcmVjb21waWxlUmVzdWx0U3RyaW5nfTsgYCwge1xuICAgIGJhYmVscmM6IGZhbHNlLFxuICAgIGNvbmZpZ0ZpbGU6IGZhbHNlLFxuICB9KSBhcyB0LkZpbGU7XG5cbiAgbGV0IHRlbXBsYXRlRXhwcmVzc2lvbiA9IChwcmVjb21waWxlUmVzdWx0QVNULnByb2dyYW0uYm9keVswXSBhcyB0LlZhcmlhYmxlRGVjbGFyYXRpb24pXG4gICAgLmRlY2xhcmF0aW9uc1swXS5pbml0IGFzIHQuRXhwcmVzc2lvbjtcblxuICB0LmFkZENvbW1lbnQoXG4gICAgdGVtcGxhdGVFeHByZXNzaW9uLFxuICAgICdsZWFkaW5nJyxcbiAgICBgXFxuICAke3RlbXBsYXRlLnJlcGxhY2UoL1xcKlxcLy9nLCAnKlxcXFwvJyl9XFxuYCxcbiAgICAvKiBsaW5lIGNvbW1lbnQ/ICovIGZhbHNlXG4gICk7XG5cbiAgc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQsIChpKSA9PiB7XG4gICAgbGV0IHRlbXBsYXRlRmFjdG9yeUlkZW50aWZpZXIgPSBpLmltcG9ydChcbiAgICAgIHN0YXRlLnRlbXBsYXRlRmFjdG9yeS5tb2R1bGVOYW1lLFxuICAgICAgc3RhdGUudGVtcGxhdGVGYWN0b3J5LmV4cG9ydE5hbWVcbiAgICApO1xuXG4gICAgbGV0IGV4cHJlc3Npb24gPSB0LmNhbGxFeHByZXNzaW9uKHRlbXBsYXRlRmFjdG9yeUlkZW50aWZpZXIsIFt0ZW1wbGF0ZUV4cHJlc3Npb25dKTtcblxuICAgIGlmIChjb25maWcucmZjOTMxU3VwcG9ydCkge1xuICAgICAgZXhwcmVzc2lvbiA9IHQuY2FsbEV4cHJlc3Npb24oaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQnLCAnc2V0Q29tcG9uZW50VGVtcGxhdGUnKSwgW1xuICAgICAgICBleHByZXNzaW9uLFxuICAgICAgICBiYWNraW5nQ2xhc3M/Lm5vZGUgPz9cbiAgICAgICAgICB0LmNhbGxFeHByZXNzaW9uKFxuICAgICAgICAgICAgaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQvdGVtcGxhdGUtb25seScsICdkZWZhdWx0JywgJ3RlbXBsYXRlT25seScpLFxuICAgICAgICAgICAgW11cbiAgICAgICAgICApLFxuICAgICAgXSk7XG4gICAgfVxuICAgIHJldHVybiBleHByZXNzaW9uO1xuICB9KTtcblxuICByZW1hcEFuZEJpbmRJZGVudGlmaWVycyh0YXJnZXQsIGJhYmVsLCBzY29wZUxvY2Fscyk7XG59XG5cbmZ1bmN0aW9uIGluc2VydFRyYW5zZm9ybWVkVGVtcGxhdGU8RW52U3BlY2lmaWNPcHRpb25zPihcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgc3RhdGU6IFN0YXRlPEVudlNwZWNpZmljT3B0aW9ucz4sXG4gIHRlbXBsYXRlOiBzdHJpbmcsXG4gIHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4gfCBOb2RlUGF0aDx0LlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvbj4sXG4gIHVzZXJUeXBlZE9wdGlvbnM6IFJlY29yZDxzdHJpbmcsIHVua25vd24+LFxuICBmb3JtYXRPcHRpb25zOiBNb2R1bGVDb25maWcsXG4gIGJhY2tpbmdDbGFzczogTm9kZVBhdGg8UGFyYW1ldGVyczx0eXBlb2YgdC5jYWxsRXhwcmVzc2lvbj5bMV1bbnVtYmVyXT4gfCB1bmRlZmluZWRcbikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2NvcGVMb2NhbHMgPSBidWlsZFNjb3BlTG9jYWxzKHVzZXJUeXBlZE9wdGlvbnMsIGZvcm1hdE9wdGlvbnMsIHRhcmdldCk7XG4gIGxldCBvcHRpb25zID0gYnVpbGRQcmVjb21waWxlT3B0aW9ucyhcbiAgICBiYWJlbCxcbiAgICB0YXJnZXQsXG4gICAgc3RhdGUsXG4gICAgdGVtcGxhdGUsXG4gICAgdXNlclR5cGVkT3B0aW9ucyxcbiAgICBmb3JtYXRPcHRpb25zLFxuICAgIHNjb3BlTG9jYWxzXG4gICk7XG4gIGxldCBhc3QgPSBwcmVwcm9jZXNzKHRlbXBsYXRlLCB7IC4uLm9wdGlvbnMsIG1vZGU6ICdjb2RlbW9kJyB9KTtcbiAgbGV0IHRyYW5zZm9ybWVkID0gcHJpbnQoYXN0LCB7IGVudGl0eUVuY29kaW5nOiAncmF3JyB9KTtcblxuICBpZiAodGFyZ2V0LmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgIHVwZGF0ZUNhbGxGb3JtPEVudlNwZWNpZmljT3B0aW9ucz4oXG4gICAgICB0YXJnZXQsXG4gICAgICB0cmFuc2Zvcm1lZCxcbiAgICAgIGZvcm1hdE9wdGlvbnMsXG4gICAgICBzY29wZUxvY2FscyxcbiAgICAgIHN0YXRlLFxuICAgICAgYmFiZWwsXG4gICAgICBiYWNraW5nQ2xhc3NcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZUJhY2t0aWNrRm9ybTxFbnZTcGVjaWZpY09wdGlvbnM+KHNjb3BlTG9jYWxzLCBzdGF0ZSwgdGFyZ2V0LCB0LCB0cmFuc2Zvcm1lZCwgYmFiZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUJhY2t0aWNrRm9ybTxFbnZTcGVjaWZpY09wdGlvbnM+KFxuICBzY29wZUxvY2FsczogU2NvcGVMb2NhbHMsXG4gIHN0YXRlOiBTdGF0ZTxFbnZTcGVjaWZpY09wdGlvbnM+LFxuICB0YXJnZXQ6IE5vZGVQYXRoPHQuVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uPixcbiAgdDogdHlwZW9mIEJhYmVsLnR5cGVzLFxuICB0cmFuc2Zvcm1lZDogc3RyaW5nLFxuICBiYWJlbDogdHlwZW9mIEJhYmVsXG4pIHtcbiAgaWYgKHNjb3BlTG9jYWxzLmlzRW1wdHkoKSkge1xuICAgIC8vIHNpbXBsZSBjYXNlOiBqdXN0IHJlcGxhY2UgdGhlIHN0cmluZyBsaXRlcmFsIHBhcnQgd2l0aCB0aGUgdHJhbnNmb3JtZWRcbiAgICAvLyB0ZW1wbGF0ZSBjb250ZW50c1xuICAgICh0YXJnZXQuZ2V0KCdxdWFzaScpLmdldCgncXVhc2lzLjAnKSBhcyBOb2RlUGF0aDx0LlRlbXBsYXRlRWxlbWVudD4pLnJlcGxhY2VXaXRoKFxuICAgICAgdC50ZW1wbGF0ZUVsZW1lbnQoeyByYXc6IHRyYW5zZm9ybWVkIH0pXG4gICAgKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBuZWVkIHRvIGFkZCBzY29wZSwgc28gbmVlZCB0byByZXBsYWNlIHRoZSBiYWNrdGlja3MgZm9ybSB3aXRoIGEgY2FsbFxuICAvLyBleHByZXNzaW9uIHRvIHByZWNvbXBpbGVUZW1wbGF0ZVxuICBtYXliZVBydW5lSW1wb3J0KHN0YXRlLnV0aWwsIHRhcmdldC5nZXQoJ3RhZycpKTtcbiAgbGV0IG5ld0NhbGwgPSBzdGF0ZS51dGlsLnJlcGxhY2VXaXRoKHRhcmdldCwgKGkpID0+XG4gICAgdC5jYWxsRXhwcmVzc2lvbihwcmVjb21waWxlVGVtcGxhdGUoaSksIFt0LnN0cmluZ0xpdGVyYWwodHJhbnNmb3JtZWQpXSlcbiAgKTtcbiAgdXBkYXRlU2NvcGUoYmFiZWwsIG5ld0NhbGwsIHNjb3BlTG9jYWxzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2FsbEZvcm08RW52U3BlY2lmaWNPcHRpb25zPihcbiAgdGFyZ2V0OiBOb2RlUGF0aDxCYWJlbC50eXBlcy5DYWxsRXhwcmVzc2lvbj4sXG4gIHRyYW5zZm9ybWVkOiBzdHJpbmcsXG4gIGZvcm1hdE9wdGlvbnM6IE1vZHVsZUNvbmZpZyxcbiAgc2NvcGVMb2NhbHM6IFNjb3BlTG9jYWxzLFxuICBzdGF0ZTogU3RhdGU8RW52U3BlY2lmaWNPcHRpb25zPixcbiAgYmFiZWw6IHR5cGVvZiBCYWJlbCxcbiAgYmFja2luZ0NsYXNzOlxuICAgIHwgTm9kZVBhdGg8QmFiZWwudHlwZXMuRXhwcmVzc2lvbiB8IEJhYmVsLnR5cGVzLkFyZ3VtZW50UGxhY2Vob2xkZXIgfCBCYWJlbC50eXBlcy5TcHJlYWRFbGVtZW50PlxuICAgIHwgdW5kZWZpbmVkXG4pIHtcbiAgLy8gZmlyc3QgdGhlIHNpbXBsZSBwYXJ0OiByZXBsYWNpbmcgdGhlIHN0cmluZyBsaXRlcmFsIHdpdGggdGhlIGFjdHVhbCBib2R5IG9mXG4gIC8vIHRoZSByZXdyaXR0ZW4gdGVtcGxhdGVcbiAgKHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4wJykgYXMgTm9kZVBhdGg8dC5Ob2RlPikucmVwbGFjZVdpdGgoXG4gICAgYmFiZWwudHlwZXMuc3RyaW5nTGl0ZXJhbCh0cmFuc2Zvcm1lZClcbiAgKTtcblxuICBpZiAoIWZvcm1hdE9wdGlvbnMuZW5hYmxlU2NvcGUgJiYgIXNjb3BlTG9jYWxzLmlzRW1wdHkoKSkge1xuICAgIC8vIGFuIEFTVCB0cmFuc2Zvcm0gYWRkZWQgbGV4aWNhbGx5IHNjb3BlZCB2YWx1ZXMgdG8gYSB0ZW1wbGF0ZSB0aGF0XG4gICAgLy8gd2Fzbid0IGFscmVhZHkgaW4gYSBmb3JtIHRoYXQgc3VwcG9ydHMgdGhlbSwgc28gY29udmVydCBmb3JtLlxuICAgIG1heWJlUHJ1bmVJbXBvcnQoc3RhdGUudXRpbCwgdGFyZ2V0LmdldCgnY2FsbGVlJykpO1xuICAgIHN0YXRlLnV0aWwucmVwbGFjZVdpdGgodGFyZ2V0LmdldCgnY2FsbGVlJyksIChpKSA9PiBwcmVjb21waWxlVGVtcGxhdGUoaSkpO1xuICB9XG5cbiAgaWYgKGZvcm1hdE9wdGlvbnMucmZjOTMxU3VwcG9ydCA9PT0gJ3BvbHlmaWxsZWQnKSB7XG4gICAgbWF5YmVQcnVuZUltcG9ydChzdGF0ZS51dGlsLCB0YXJnZXQuZ2V0KCdjYWxsZWUnKSk7XG4gICAgc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQuZ2V0KCdjYWxsZWUnKSwgKGkpID0+IHByZWNvbXBpbGVUZW1wbGF0ZShpKSk7XG4gICAgY29udmVydFN0cmljdE1vZGUoYmFiZWwsIHRhcmdldCk7XG4gICAgcmVtb3ZlRXZhbEFuZFNjb3BlKHRhcmdldCk7XG4gICAgdGFyZ2V0Lm5vZGUuYXJndW1lbnRzID0gdGFyZ2V0Lm5vZGUuYXJndW1lbnRzLnNsaWNlKDAsIDIpO1xuICAgIHN0YXRlLnJlY3Vyc2lvbkd1YXJkLmFkZCh0YXJnZXQubm9kZSk7XG4gICAgc3RhdGUudXRpbC5yZXBsYWNlV2l0aCh0YXJnZXQsIChpKSA9PlxuICAgICAgYmFiZWwudHlwZXMuY2FsbEV4cHJlc3Npb24oaS5pbXBvcnQoJ0BlbWJlci9jb21wb25lbnQnLCAnc2V0Q29tcG9uZW50VGVtcGxhdGUnKSwgW1xuICAgICAgICB0YXJnZXQubm9kZSxcbiAgICAgICAgYmFja2luZ0NsYXNzPy5ub2RlID8/XG4gICAgICAgICAgYmFiZWwudHlwZXMuY2FsbEV4cHJlc3Npb24oXG4gICAgICAgICAgICBpLmltcG9ydCgnQGVtYmVyL2NvbXBvbmVudC90ZW1wbGF0ZS1vbmx5JywgJ2RlZmF1bHQnLCAndGVtcGxhdGVPbmx5JyksXG4gICAgICAgICAgICBbXVxuICAgICAgICAgICksXG4gICAgICBdKVxuICAgICk7XG4gICAgLy8gd2UganVzdCB3cmFwcGVkIHRoZSB0YXJnZXQgY2FsbEV4cHJlc3Npb24gaW4gdGhlIGNhbGwgdG9cbiAgICAvLyBzZXRDb21wb25lbnRUZW1wbGF0ZS4gQWRqdXN0IGB0YXJnZXRgIGJhY2sgdG8gcG9pbnQgYXQgdGhlXG4gICAgLy8gcHJlY29tcGlsZVRlbXBsYXRlIGNhbGwgZm9yIHRoZSBmaW5hbCB1cGRhdGVTY29wZSBiZWxvdy5cbiAgICAvL1xuICAgIHRhcmdldCA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4wJykgYXMgTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj47XG4gIH1cblxuICAvLyBXZSBkZWxpYmVyYXRlbHkgZG8gdXBkYXRlU2NvcGUgYXQgdGhlIGVuZCBzbyB0aGF0IHdoZW4gaXQgdXBkYXRlc1xuICAvLyByZWZlcmVuY2VzLCB0aG9zZSByZWZlcmVuY2VzIHdpbGwgcG9pbnQgdG8gdGhlIGFjY3VyYXRlIHBhdGhzIGluIHRoZVxuICAvLyBmaW5hbCBBU1QuXG4gIHVwZGF0ZVNjb3BlKGJhYmVsLCB0YXJnZXQsIHNjb3BlTG9jYWxzKTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVGYWN0b3J5Q29uZmlnKG9wdHM6IE5vcm1hbGl6ZWRPcHRzKSB7XG4gIGxldCBtb2R1bGVOYW1lID0gJ0BlbWJlci90ZW1wbGF0ZS1mYWN0b3J5JztcbiAgbGV0IGV4cG9ydE5hbWUgPSAnY3JlYXRlVGVtcGxhdGVGYWN0b3J5JztcbiAgbGV0IG92ZXJyaWRlcyA9IG9wdHMub3V0cHV0TW9kdWxlT3ZlcnJpZGVzW21vZHVsZU5hbWVdPy5bZXhwb3J0TmFtZV07XG4gIHJldHVybiBvdmVycmlkZXNcbiAgICA/IHsgZXhwb3J0TmFtZTogb3ZlcnJpZGVzWzBdLCBtb2R1bGVOYW1lOiBvdmVycmlkZXNbMV0gfVxuICAgIDogeyBleHBvcnROYW1lLCBtb2R1bGVOYW1lIH07XG59XG5cbmZ1bmN0aW9uIGJ1aWxkU2NvcGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgbG9jYWxzOiBTY29wZUxvY2Fscykge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuXG4gIHJldHVybiB0LmFycm93RnVuY3Rpb25FeHByZXNzaW9uKFxuICAgIFtdLFxuICAgIHQub2JqZWN0RXhwcmVzc2lvbihcbiAgICAgIGxvY2Fsc1xuICAgICAgICAuZW50cmllcygpXG4gICAgICAgIC5tYXAoKFtuYW1lLCBpZGVudGlmaWVyXSkgPT5cbiAgICAgICAgICB0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcihuYW1lKSwgdC5pZGVudGlmaWVyKGlkZW50aWZpZXIpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgKVxuICAgIClcbiAgKTtcbn1cblxuLy8gdGhpcyBpcyByZXNwb25zaWJsZSBib3RoIGZvciBhZGp1c3RpbmcgdGhlIEFTVCBmb3Igb3VyIHNjb3BlIGFyZ3VtZW50ICphbmQqXG4vLyBlbnN1cmluZyB0aGF0IGJhYmVsJ3Mgc2NvcGUgc3lzdGVtIHdpbGwgc2VlIHRoYXQgdGhlc2UgbmV3IGlkZW50aWZpZXJzXG4vLyByZWZlcmVuY2UgdGhlaXIgYmluZGluZ3MuIEBiYWJlbC9wbHVnaW4tdHJhbnNmb3JtLXR5cGVzY3JpcHQgaW4gcGFydGljdWxhclxuLy8gY2FyZXMgYW4gYXdmdWwgbG90IGFib3V0IHdoZXRoZXIgYW4gaW1wb3J0IGhhcyB2YWxpZCBub24tdHlwZSByZWZlcmVuY2VzLCBzb1xuLy8gdGhlc2UgbmV3bHkgaW50cm9kdWNkIHJlZmVyZW5jZXMgbmVlZCB0byBiZSB2YWxpZC5cbmZ1bmN0aW9uIHVwZGF0ZVNjb3BlKGJhYmVsOiB0eXBlb2YgQmFiZWwsIHRhcmdldDogTm9kZVBhdGg8dC5DYWxsRXhwcmVzc2lvbj4sIGxvY2FsczogU2NvcGVMb2NhbHMpIHtcbiAgbGV0IHQgPSBiYWJlbC50eXBlcztcbiAgbGV0IHNlY29uZEFyZyA9IHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4xJykgYXMgTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPiB8IHVuZGVmaW5lZDtcbiAgaWYgKHNlY29uZEFyZykge1xuICAgIGxldCBzY29wZSA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdzY29wZSc7XG4gICAgfSk7XG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICBpZiAobG9jYWxzLmlzRW1wdHkoKSkge1xuICAgICAgICBzY29wZS5yZW1vdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNjb3BlLnNldCgndmFsdWUnLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKTtcbiAgICAgICAgLy8gZnVubnktbG9va2luZyBuYW1pbmcgaGVyZSwgYnV0IGl0IGFjdHVhbGx5IG1ha2VzIHNlbnNlIGJlY2F1c2Ugd2UncmVcbiAgICAgICAgLy8gY29ubmVjdGluZyB0aGUgZ2xpbW1lciBzY29wZSBzeXN0ZW0gd2l0aCB0aGUgYmFiZWwgc2NvcGUgc3lzdGVtLlxuICAgICAgICBzY29wZS5zY29wZS5jcmF3bCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICAgIHNlY29uZEFyZy5wdXNoQ29udGFpbmVyKFxuICAgICAgICAncHJvcGVydGllcycsXG4gICAgICAgIHQub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzY29wZScpLCBidWlsZFNjb3BlKGJhYmVsLCBsb2NhbHMpKVxuICAgICAgKTtcbiAgICAgIChcbiAgICAgICAgc2Vjb25kQXJnLmdldChcbiAgICAgICAgICBgcHJvcGVydGllcy4ke3NlY29uZEFyZy5ub2RlLnByb3BlcnRpZXMubGVuZ3RoIC0gMX1gXG4gICAgICAgICkgYXMgTm9kZVBhdGg8dC5PYmplY3RQcm9wZXJ0eT5cbiAgICAgICkuc2NvcGUuY3Jhd2woKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWxvY2Fscy5pc0VtcHR5KCkpIHtcbiAgICB0YXJnZXQucHVzaENvbnRhaW5lcihcbiAgICAgICdhcmd1bWVudHMnLFxuICAgICAgdC5vYmplY3RFeHByZXNzaW9uKFt0Lm9iamVjdFByb3BlcnR5KHQuaWRlbnRpZmllcignc2NvcGUnKSwgYnVpbGRTY29wZShiYWJlbCwgbG9jYWxzKSldKVxuICAgICk7XG4gICAgKHRhcmdldC5nZXQoJ2FyZ3VtZW50cy4xJykgYXMgTm9kZVBhdGg8dC5PYmplY3RFeHByZXNzaW9uPikuc2NvcGUuY3Jhd2woKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVFdmFsQW5kU2NvcGUodGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPikge1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IGV2YWxQcm9wID0gc2Vjb25kQXJnLmdldCgncHJvcGVydGllcycpLmZpbmQoKHApID0+IHtcbiAgICAgIGxldCBrZXkgPSBwLmdldCgna2V5JykgYXMgTm9kZVBhdGg8dC5Ob2RlPjtcbiAgICAgIHJldHVybiBrZXkuaXNJZGVudGlmaWVyKCkgJiYga2V5Lm5vZGUubmFtZSA9PT0gJ2V2YWwnO1xuICAgIH0pO1xuICAgIGlmIChldmFsUHJvcCkge1xuICAgICAgZXZhbFByb3AucmVtb3ZlKCk7XG4gICAgfVxuXG4gICAgbGV0IGNvbXBvbmVudFByb3AgPSBzZWNvbmRBcmcuZ2V0KCdwcm9wZXJ0aWVzJykuZmluZCgocCkgPT4ge1xuICAgICAgbGV0IGtleSA9IHAuZ2V0KCdrZXknKSBhcyBOb2RlUGF0aDx0Lk5vZGU+O1xuICAgICAgcmV0dXJuIGtleS5pc0lkZW50aWZpZXIoKSAmJiBrZXkubm9kZS5uYW1lID09PSAnY29tcG9uZW50JztcbiAgICB9KTtcbiAgICBpZiAoY29tcG9uZW50UHJvcCkge1xuICAgICAgY29tcG9uZW50UHJvcC5yZW1vdmUoKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gR2l2ZW4gYSBjYWxsIHRvIHRlbXBsYXRlKCksIGNvbnZlcnQgaXRzIFwic3RyaWN0XCIgYXJndW1lbnQgaW50b1xuLy8gcHJlY29tcGlsZVRlbXBsYXRlJ3MgXCJzdHJpY3RNb2RlXCIgYXJndW1lbnQuIFRoZXkgZGlmZmVyIGluIG5hbWUgYW5kIGRlZmF1bHRcbi8vIHZhbHVlLlxuZnVuY3Rpb24gY29udmVydFN0cmljdE1vZGUoYmFiZWw6IHR5cGVvZiBCYWJlbCwgdGFyZ2V0OiBOb2RlUGF0aDx0LkNhbGxFeHByZXNzaW9uPikge1xuICBsZXQgdCA9IGJhYmVsLnR5cGVzO1xuICBsZXQgc2Vjb25kQXJnID0gdGFyZ2V0LmdldCgnYXJndW1lbnRzLjEnKSBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+IHwgdW5kZWZpbmVkO1xuICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgbGV0IHN0cmljdCA9IHNlY29uZEFyZy5nZXQoJ3Byb3BlcnRpZXMnKS5maW5kKChwKSA9PiB7XG4gICAgICBsZXQga2V5ID0gcC5nZXQoJ2tleScpIGFzIE5vZGVQYXRoPHQuTm9kZT47XG4gICAgICByZXR1cm4ga2V5LmlzSWRlbnRpZmllcigpICYmIGtleS5ub2RlLm5hbWUgPT09ICdzdHJpY3QnO1xuICAgIH0pIGFzIE5vZGVQYXRoPHQuT2JqZWN0UHJvcGVydHk+O1xuICAgIGlmIChzdHJpY3QpIHtcbiAgICAgIHN0cmljdC5zZXQoJ2tleScsIHQuaWRlbnRpZmllcignc3RyaWN0TW9kZScpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2Vjb25kQXJnLnB1c2hDb250YWluZXIoXG4gICAgICAgICdwcm9wZXJ0aWVzJyxcbiAgICAgICAgdC5vYmplY3RQcm9wZXJ0eSh0LmlkZW50aWZpZXIoJ3N0cmljdE1vZGUnKSwgdC5ib29sZWFuTGl0ZXJhbCh0cnVlKSlcbiAgICAgICk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRhcmdldC5wdXNoQ29udGFpbmVyKFxuICAgICAgJ2FyZ3VtZW50cycsXG4gICAgICB0Lm9iamVjdEV4cHJlc3Npb24oW3Qub2JqZWN0UHJvcGVydHkodC5pZGVudGlmaWVyKCdzdHJpY3RNb2RlJyksIHQuYm9vbGVhbkxpdGVyYWwodHJ1ZSkpXSlcbiAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUHJ1bmVJbXBvcnQoXG4gIHV0aWw6IEltcG9ydFV0aWwsXG4gIGlkZW50aWZpZXI6IE5vZGVQYXRoPHQuRXhwcmVzc2lvbiB8IHQuVjhJbnRyaW5zaWNJZGVudGlmaWVyPlxuKSB7XG4gIGlmICghaWRlbnRpZmllci5pc0lkZW50aWZpZXIoKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgYmluZGluZyA9IGlkZW50aWZpZXIuc2NvcGUuZ2V0QmluZGluZyhpZGVudGlmaWVyLm5vZGUubmFtZSk7XG4gIC8vIHRoaXMgY2hlY2tzIGlmIHRoZSBpZGVudGlmaWVyICh0aGF0IHdlJ3JlIGFib3V0IHRvIHJlbW92ZSkgaXMgdXNlZCBpblxuICAvLyBleGFjdGx5IG9uZSBwbGFjZS5cbiAgaWYgKFxuICAgIGJpbmRpbmc/LnJlZmVyZW5jZVBhdGhzLnJlZHVjZSgoY291bnQsIHBhdGgpID0+IChwYXRoLnJlbW92ZWQgPyBjb3VudCA6IGNvdW50ICsgMSksIDApID09PSAxXG4gICkge1xuICAgIGxldCBzcGVjaWZpZXIgPSBiaW5kaW5nLnBhdGg7XG4gICAgaWYgKHNwZWNpZmllci5pc0ltcG9ydFNwZWNpZmllcigpKSB7XG4gICAgICBsZXQgZGVjbGFyYXRpb24gPSBzcGVjaWZpZXIucGFyZW50UGF0aCBhcyBOb2RlUGF0aDx0LkltcG9ydERlY2xhcmF0aW9uPjtcbiAgICAgIHV0aWwucmVtb3ZlSW1wb3J0KGRlY2xhcmF0aW9uLm5vZGUuc291cmNlLnZhbHVlLCBuYW1lKHNwZWNpZmllci5ub2RlLmltcG9ydGVkKSk7XG4gICAgfVxuICB9XG4gIGlkZW50aWZpZXIucmVtb3ZlZCA9IHRydWU7XG59XG5cbmZ1bmN0aW9uIHByZWNvbXBpbGVUZW1wbGF0ZShpOiBJbXBvcnRlcikge1xuICByZXR1cm4gaS5pbXBvcnQoJ0BlbWJlci90ZW1wbGF0ZS1jb21waWxhdGlvbicsICdwcmVjb21waWxlVGVtcGxhdGUnKTtcbn1cblxuZnVuY3Rpb24gbmFtZShub2RlOiB0LlN0cmluZ0xpdGVyYWwgfCB0LklkZW50aWZpZXIpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gJ1N0cmluZ0xpdGVyYWwnKSB7XG4gICAgcmV0dXJuIG5vZGUudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBtYWtlUGx1Z2luPE9wdGlvbnM+KChvcHRpb25zKSA9PiBvcHRpb25zKTtcbiJdfQ==