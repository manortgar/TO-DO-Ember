"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressionParser = void 0;
const scope_locals_1 = require("./scope-locals");
class ExpressionParser {
    constructor(babel) {
        this.babel = babel;
    }
    parseExpression(invokedName, path) {
        switch (path.node.type) {
            case 'ObjectExpression':
                return this.parseObjectExpression(invokedName, path);
            case 'ArrayExpression': {
                return this.parseArrayExpression(invokedName, path);
            }
            case 'StringLiteral':
            case 'BooleanLiteral':
            case 'NumericLiteral':
                return path.node.value;
            default:
                throw path.buildCodeFrameError(`${invokedName} can only accept static options but you passed ${JSON.stringify(path.node)}`);
        }
    }
    parseArrayExpression(invokedName, path) {
        return path.get('elements').map((element) => {
            if (element.isSpreadElement()) {
                throw element.buildCodeFrameError(`spread element is not allowed here`);
            }
            else if (element.isExpression()) {
                return this.parseExpression(invokedName, element);
            }
        });
    }
    parseScope(invokedName, path) {
        let body = undefined;
        if (path.node.type === 'ObjectMethod') {
            body = path.node.body;
        }
        else {
            let { value } = path.node;
            if (this.t.isObjectExpression(value)) {
                throw path.buildCodeFrameError(`Passing an object as the \`scope\` property to inline templates is no longer supported. Please pass a function that returns an object expression instead.`);
            }
            if (this.t.isFunctionExpression(value) || this.t.isArrowFunctionExpression(value)) {
                body = value.body;
            }
        }
        let objExpression = undefined;
        if ((body === null || body === void 0 ? void 0 : body.type) === 'ObjectExpression') {
            objExpression = body;
        }
        else if ((body === null || body === void 0 ? void 0 : body.type) === 'BlockStatement') {
            // SAFETY: We know that the body is a ReturnStatement because we're checking inside
            let returnStatements = body.body.filter((statement) => statement.type === 'ReturnStatement');
            if (returnStatements.length !== 1) {
                throw new Error('Scope functions must have a single return statement which returns an object expression containing references to in-scope values');
            }
            objExpression = returnStatements[0].argument;
        }
        if ((objExpression === null || objExpression === void 0 ? void 0 : objExpression.type) !== 'ObjectExpression') {
            throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` must be an object expression containing only references to in-scope values, or a function that returns an object expression containing only references to in-scope values`);
        }
        return objExpression.properties.reduce((res, prop) => {
            if (this.t.isSpreadElement(prop)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may not contain spread elements`);
            }
            if (this.t.isObjectMethod(prop)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may not contain methods`);
            }
            let { key, value } = prop;
            if (!this.t.isStringLiteral(key) && !this.t.isIdentifier(key)) {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may only contain static property names`);
            }
            let propName = name(key);
            if (value.type !== 'Identifier') {
                throw path.buildCodeFrameError(`Scope objects for \`${invokedName}\` may only contain direct references to in-scope values, e.g. { ${propName} } or { ${propName}: ${propName} }`);
            }
            res.add(propName, value.name);
            return res;
        }, new scope_locals_1.ScopeLocals({ mode: 'explicit' }));
    }
    parseEval(invokedName, path) {
        let body;
        if (path.isObjectMethod()) {
            body = path.get('body');
        }
        else if (path.isObjectProperty()) {
            let value = path.get('value');
            if (value.isFunctionExpression()) {
                body = value.get('body');
            }
            else {
                throw path.buildCodeFrameError(`unsupported syntax for \`eval\` parameter to \`${invokedName}\`. It must be an object method or a function.`);
            }
        }
        else {
            throw path.buildCodeFrameError(`unsupported syntax for \`eval\` parameter to \`${invokedName}\`. It must be an object method or a function.`);
        }
        let returnStatements = body
            .get('body')
            .filter((statement) => statement.isReturnStatement());
        if (returnStatements.length !== 1) {
            throw body.buildCodeFrameError('eval function must have a single return statement');
        }
        let returnExpression = returnStatements[0].get('argument');
        if (!returnExpression.isCallExpression()) {
            throw returnStatements[0].buildCodeFrameError('eval function must return `eval(arguments[0])`. Found non-CallExpression.');
        }
        let callee = returnExpression.get('callee');
        if (!callee.isIdentifier() || callee.node.name !== 'eval') {
            throw returnExpression.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found callee is not eval.');
        }
        let args = returnExpression.get('arguments');
        if (args.length !== 1) {
            throw returnExpression.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found incorrect number of arguments.');
        }
        let arg = args[0];
        if (!arg.isMemberExpression()) {
            throw arg.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found argument is non-MemberExpression.');
        }
        let obj = arg.get('object');
        if (!obj.isIdentifier() || obj.node.name !== 'arguments') {
            throw obj.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found wrong argument to eval.');
        }
        let prop = arg.get('property');
        if (!prop.isNumericLiteral() || prop.node.value !== 0) {
            throw prop.buildCodeFrameError('eval function must return `eval(arguments[0])`. Found wrong property.');
        }
        return { isEval: true };
    }
    parseObjectExpression(invokedName, path, shouldParseScope = false, shouldSupportRFC931 = false) {
        let result = {};
        path.get('properties').forEach((property) => {
            let { node } = property;
            if (this.t.isSpreadElement(node)) {
                throw property.buildCodeFrameError(`${invokedName} does not allow spread element`);
            }
            if (node.computed) {
                throw property.buildCodeFrameError(`${invokedName} can only accept static property names`);
            }
            let { key } = node;
            if (!this.t.isIdentifier(key) && !this.t.isStringLiteral(key)) {
                throw property.buildCodeFrameError(`${invokedName} can only accept static property names`);
            }
            let propertyName = name(key);
            if (shouldParseScope && propertyName === 'scope') {
                result.scope = this.parseScope(invokedName, property);
            }
            else if (shouldSupportRFC931 && propertyName === 'eval') {
                result.eval = this.parseEval(invokedName, property);
            }
            else if (shouldSupportRFC931 && propertyName === 'component') {
                result.component = property.get('value');
            }
            else {
                if (this.t.isObjectMethod(node)) {
                    throw property.buildCodeFrameError(`${invokedName} does not accept a method for ${propertyName}`);
                }
                let valuePath = property.get('value');
                if (!valuePath.isExpression()) {
                    throw valuePath.buildCodeFrameError(`must be an expression`);
                }
                result[propertyName] = this.parseExpression(invokedName, valuePath);
            }
        });
        return result;
    }
    get t() {
        return this.babel.types;
    }
}
exports.ExpressionParser = ExpressionParser;
function name(node) {
    if (node.type === 'StringLiteral') {
        return node.value;
    }
    else {
        return node.name;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhwcmVzc2lvbi1wYXJzZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJleHByZXNzaW9uLXBhcnNlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFHQSxpREFBNkM7QUFFN0MsTUFBYSxnQkFBZ0I7SUFDM0IsWUFBb0IsS0FBbUI7UUFBbkIsVUFBSyxHQUFMLEtBQUssQ0FBYztJQUFHLENBQUM7SUFFM0MsZUFBZSxDQUFDLFdBQW1CLEVBQUUsSUFBNEI7UUFDL0QsUUFBUSxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRTtZQUN0QixLQUFLLGtCQUFrQjtnQkFDckIsT0FBTyxJQUFJLENBQUMscUJBQXFCLENBQUMsV0FBVyxFQUFFLElBQW9DLENBQUMsQ0FBQztZQUN2RixLQUFLLGlCQUFpQixDQUFDLENBQUM7Z0JBQ3RCLE9BQU8sSUFBSSxDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxJQUFtQyxDQUFDLENBQUM7YUFDcEY7WUFDRCxLQUFLLGVBQWUsQ0FBQztZQUNyQixLQUFLLGdCQUFnQixDQUFDO1lBQ3RCLEtBQUssZ0JBQWdCO2dCQUNuQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ3pCO2dCQUNFLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUM1QixHQUFHLFdBQVcsa0RBQWtELElBQUksQ0FBQyxTQUFTLENBQzVFLElBQUksQ0FBQyxJQUFJLENBQ1YsRUFBRSxDQUNKLENBQUM7U0FDTDtJQUNILENBQUM7SUFFRCxvQkFBb0IsQ0FBQyxXQUFtQixFQUFFLElBQWlDO1FBQ3pFLE9BQU8sSUFBSSxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRTtZQUMxQyxJQUFJLE9BQU8sQ0FBQyxlQUFlLEVBQUUsRUFBRTtnQkFDN0IsTUFBTSxPQUFPLENBQUMsbUJBQW1CLENBQUMsb0NBQW9DLENBQUMsQ0FBQzthQUN6RTtpQkFBTSxJQUFJLE9BQU8s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QyxDQUFDO2FBQ3JFO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsSUFBWSxDQUFDO1FBQ1gsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQztJQUMxQixDQUFDO0NBQ0Y7QUF2T0QsNENBdU9DO0FBRUQsU0FBUyxJQUFJLENBQUMsSUFBb0M7SUFDaEQsSUFBSSxJQUFJLENBQUMsSUFBSSxLQUFLLGVBQWUsRUFBRTtRQUNqQyxPQUFPLElBQUksQ0FBQyxLQUFLLENBQUM7S0FDbkI7U0FBTTtRQUNMLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBQztLQUNsQjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdHlwZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB0eXBlICogYXMgQmFiZWwgZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHR5cGUgeyB0eXBlcyBhcyB0IH0gZnJvbSAnQGJhYmVsL2NvcmUnO1xuaW1wb3J0IHsgU2NvcGVMb2NhbHMgfSBmcm9tICcuL3Njb3BlLWxvY2Fscyc7XG5cbmV4cG9ydCBjbGFzcyBFeHByZXNzaW9uUGFyc2VyIHtcbiAgY29uc3RydWN0b3IocHJpdmF0ZSBiYWJlbDogdHlwZW9mIEJhYmVsKSB7fVxuXG4gIHBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZTogc3RyaW5nLCBwYXRoOiBOb2RlUGF0aDx0LkV4cHJlc3Npb24+KTogdW5rbm93biB7XG4gICAgc3dpdGNoIChwYXRoLm5vZGUudHlwZSkge1xuICAgICAgY2FzZSAnT2JqZWN0RXhwcmVzc2lvbic6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlT2JqZWN0RXhwcmVzc2lvbihpbnZva2VkTmFtZSwgcGF0aCBhcyBOb2RlUGF0aDx0Lk9iamVjdEV4cHJlc3Npb24+KTtcbiAgICAgIGNhc2UgJ0FycmF5RXhwcmVzc2lvbic6IHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VBcnJheUV4cHJlc3Npb24oaW52b2tlZE5hbWUsIHBhdGggYXMgTm9kZVBhdGg8dC5BcnJheUV4cHJlc3Npb24+KTtcbiAgICAgIH1cbiAgICAgIGNhc2UgJ1N0cmluZ0xpdGVyYWwnOlxuICAgICAgY2FzZSAnQm9vbGVhbkxpdGVyYWwnOlxuICAgICAgY2FzZSAnTnVtZXJpY0xpdGVyYWwnOlxuICAgICAgICByZXR1cm4gcGF0aC5ub2RlLnZhbHVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGAke2ludm9rZWROYW1lfSBjYW4gb25seSBhY2NlcHQgc3RhdGljIG9wdGlvbnMgYnV0IHlvdSBwYXNzZWQgJHtKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgIHBhdGgubm9kZVxuICAgICAgICAgICl9YFxuICAgICAgICApO1xuICAgIH1cbiAgfVxuXG4gIHBhcnNlQXJyYXlFeHByZXNzaW9uKGludm9rZWROYW1lOiBzdHJpbmcsIHBhdGg6IE5vZGVQYXRoPHQuQXJyYXlFeHByZXNzaW9uPikge1xuICAgIHJldHVybiBwYXRoLmdldCgnZWxlbWVudHMnKS5tYXAoKGVsZW1lbnQpID0+IHtcbiAgICAgIGlmIChlbGVtZW50LmlzU3ByZWFkRWxlbWVudCgpKSB7XG4gICAgICAgIHRocm93IGVsZW1lbnQuYnVpbGRDb2RlRnJhbWVFcnJvcihgc3ByZWFkIGVsZW1lbnQgaXMgbm90IGFsbG93ZWQgaGVyZWApO1xuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmlzRXhwcmVzc2lvbigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcmVzc2lvbihpbnZva2VkTmFtZSwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVNjb3BlKGludm9rZWROYW1lOiBzdHJpbmcsIHBhdGg6IE5vZGVQYXRoPHQuT2JqZWN0UHJvcGVydHkgfCB0Lk9iamVjdE1ldGhvZD4pOiBTY29wZUxvY2FscyB7XG4gICAgbGV0IGJvZHk6IHQuQmxvY2tTdGF0ZW1lbnQgfCB0LkV4cHJlc3Npb24gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgICBpZiAocGF0aC5ub2RlLnR5cGUgPT09ICdPYmplY3RNZXRob2QnKSB7XG4gICAgICBib2R5ID0gcGF0aC5ub2RlLmJvZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHZhbHVlIH0gPSBwYXRoLm5vZGU7XG4gICAgICBpZiAodGhpcy50LmlzT2JqZWN0RXhwcmVzc2lvbih2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGBQYXNzaW5nIGFuIG9iamVjdCBhcyB0aGUgXFxgc2NvcGVcXGAgcHJvcGVydHkgdG8gaW5saW5lIHRlbXBsYXRlcyBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBQbGVhc2UgcGFzcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBvYmplY3QgZXhwcmVzc2lvbiBpbnN0ZWFkLmBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnQuaXNGdW5jdGlvbkV4cHJlc3Npb24odmFsdWUpIHx8IHRoaXMudC5pc0Fycm93RnVuY3Rpb25FeHByZXNzaW9uKHZhbHVlKSkge1xuICAgICAgICBib2R5ID0gdmFsdWUuYm9keTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgb2JqRXhwcmVzc2lvbjogdC5FeHByZXNzaW9uIHwgdW5kZWZpbmVkIHwgbnVsbCA9IHVuZGVmaW5lZDtcblxuICAgIGlmIChib2R5Py50eXBlID09PSAnT2JqZWN0RXhwcmVzc2lvbicpIHtcbiAgICAgIG9iakV4cHJlc3Npb24gPSBib2R5O1xuICAgIH0gZWxzZSBpZiAoYm9keT8udHlwZSA9PT0gJ0Jsb2NrU3RhdGVtZW50Jykge1xuICAgICAgLy8gU0FGRVRZOiBXZSBrbm93IHRoYXQgdGhlIGJvZHkgaXMgYSBSZXR1cm5TdGF0ZW1lbnQgYmVjYXVzZSB3ZSdyZSBjaGVja2luZyBpbnNpZGVcbiAgICAgIGxldCByZXR1cm5TdGF0ZW1lbnRzID0gYm9keS5ib2R5LmZpbHRlcihcbiAgICAgICAgKHN0YXRlbWVudCkgPT4gc3RhdGVtZW50LnR5cGUgPT09ICdSZXR1cm5TdGF0ZW1lbnQnXG4gICAgICApIGFzIEJhYmVsLnR5cGVzLlJldHVyblN0YXRlbWVudFtdO1xuXG4gICAgICBpZiAocmV0dXJuU3RhdGVtZW50cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdTY29wZSBmdW5jdGlvbnMgbXVzdCBoYXZlIGEgc2luZ2xlIHJldHVybiBzdGF0ZW1lbnQgd2hpY2ggcmV0dXJucyBhbiBvYmplY3QgZXhwcmVzc2lvbiBjb250YWluaW5nIHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBvYmpFeHByZXNzaW9uID0gcmV0dXJuU3RhdGVtZW50c1swXS5hcmd1bWVudDtcbiAgICB9XG5cbiAgICBpZiAob2JqRXhwcmVzc2lvbj8udHlwZSAhPT0gJ09iamVjdEV4cHJlc3Npb24nKSB7XG4gICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgIGBTY29wZSBvYmplY3RzIGZvciBcXGAke2ludm9rZWROYW1lfVxcYCBtdXN0IGJlIGFuIG9iamVjdCBleHByZXNzaW9uIGNvbnRhaW5pbmcgb25seSByZWZlcmVuY2VzIHRvIGluLXNjb3BlIHZhbHVlcywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYW4gb2JqZWN0IGV4cHJlc3Npb24gY29udGFpbmluZyBvbmx5IHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzYFxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gb2JqRXhwcmVzc2lvbi5wcm9wZXJ0aWVzLnJlZHVjZSgocmVzLCBwcm9wKSA9PiB7XG4gICAgICBpZiAodGhpcy50LmlzU3ByZWFkRWxlbWVudChwcm9wKSkge1xuICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgYFNjb3BlIG9iamVjdHMgZm9yIFxcYCR7aW52b2tlZE5hbWV9XFxgIG1heSBub3QgY29udGFpbiBzcHJlYWQgZWxlbWVudHNgXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy50LmlzT2JqZWN0TWV0aG9kKHByb3ApKSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgU2NvcGUgb2JqZWN0cyBmb3IgXFxgJHtpbnZva2VkTmFtZX1cXGAgbWF5IG5vdCBjb250YWluIG1ldGhvZHNgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCB7IGtleSwgdmFsdWUgfSA9IHByb3A7XG4gICAgICBpZiAoIXRoaXMudC5pc1N0cmluZ0xpdGVyYWwoa2V5KSAmJiAhdGhpcy50LmlzSWRlbnRpZmllcihrZXkpKSB7XG4gICAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgICBgU2NvcGUgb2JqZWN0cyBmb3IgXFxgJHtpbnZva2VkTmFtZX1cXGAgbWF5IG9ubHkgY29udGFpbiBzdGF0aWMgcHJvcGVydHkgbmFtZXNgXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGxldCBwcm9wTmFtZSA9IG5hbWUoa2V5KTtcblxuICAgICAgaWYgKHZhbHVlLnR5cGUgIT09ICdJZGVudGlmaWVyJykge1xuICAgICAgICB0aHJvdyBwYXRoLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgYFNjb3BlIG9iamVjdHMgZm9yIFxcYCR7aW52b2tlZE5hbWV9XFxgIG1heSBvbmx5IGNvbnRhaW4gZGlyZWN0IHJlZmVyZW5jZXMgdG8gaW4tc2NvcGUgdmFsdWVzLCBlLmcuIHsgJHtwcm9wTmFtZX0gfSBvciB7ICR7cHJvcE5hbWV9OiAke3Byb3BOYW1lfSB9YFxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXMuYWRkKHByb3BOYW1lLCB2YWx1ZS5uYW1lKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSwgbmV3IFNjb3BlTG9jYWxzKHsgbW9kZTogJ2V4cGxpY2l0JyB9KSk7XG4gIH1cblxuICBwYXJzZUV2YWwoXG4gICAgaW52b2tlZE5hbWU6IHN0cmluZyxcbiAgICBwYXRoOiBOb2RlUGF0aDx0Lk9iamVjdFByb3BlcnR5IHwgdC5PYmplY3RNZXRob2Q+XG4gICk6IHsgaXNFdmFsOiB0cnVlIH0ge1xuICAgIGxldCBib2R5OiBOb2RlUGF0aDx0LkJsb2NrU3RhdGVtZW50PjtcblxuICAgIGlmIChwYXRoLmlzT2JqZWN0TWV0aG9kKCkpIHtcbiAgICAgIGJvZHkgPSBwYXRoLmdldCgnYm9keScpO1xuICAgIH0gZWxzZSBpZiAocGF0aC5pc09iamVjdFByb3BlcnR5KCkpIHtcbiAgICAgIGxldCB2YWx1ZSA9IHBhdGguZ2V0KCd2YWx1ZScpO1xuICAgICAgaWYgKHZhbHVlLmlzRnVuY3Rpb25FeHByZXNzaW9uKCkpIHtcbiAgICAgICAgYm9keSA9IHZhbHVlLmdldCgnYm9keScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgcGF0aC5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAgIGB1bnN1cHBvcnRlZCBzeW50YXggZm9yIFxcYGV2YWxcXGAgcGFyYW1ldGVyIHRvIFxcYCR7aW52b2tlZE5hbWV9XFxgLiBJdCBtdXN0IGJlIGFuIG9iamVjdCBtZXRob2Qgb3IgYSBmdW5jdGlvbi5gXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IHBhdGguYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgYHVuc3VwcG9ydGVkIHN5bnRheCBmb3IgXFxgZXZhbFxcYCBwYXJhbWV0ZXIgdG8gXFxgJHtpbnZva2VkTmFtZX1cXGAuIEl0IG11c3QgYmUgYW4gb2JqZWN0IG1ldGhvZCBvciBhIGZ1bmN0aW9uLmBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHJldHVyblN0YXRlbWVudHMgPSBib2R5XG4gICAgICAuZ2V0KCdib2R5JylcbiAgICAgIC5maWx0ZXIoKHN0YXRlbWVudCkgPT4gc3RhdGVtZW50LmlzUmV0dXJuU3RhdGVtZW50KCkpIGFzIE5vZGVQYXRoPHQuUmV0dXJuU3RhdGVtZW50PltdO1xuXG4gICAgaWYgKHJldHVyblN0YXRlbWVudHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBib2R5LmJ1aWxkQ29kZUZyYW1lRXJyb3IoJ2V2YWwgZnVuY3Rpb24gbXVzdCBoYXZlIGEgc2luZ2xlIHJldHVybiBzdGF0ZW1lbnQnKTtcbiAgICB9XG5cbiAgICBsZXQgcmV0dXJuRXhwcmVzc2lvbiA9IHJldHVyblN0YXRlbWVudHNbMF0uZ2V0KCdhcmd1bWVudCcpO1xuXG4gICAgaWYgKCFyZXR1cm5FeHByZXNzaW9uLmlzQ2FsbEV4cHJlc3Npb24oKSkge1xuICAgICAgdGhyb3cgcmV0dXJuU3RhdGVtZW50c1swXS5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAnZXZhbCBmdW5jdGlvbiBtdXN0IHJldHVybiBgZXZhbChhcmd1bWVudHNbMF0pYC4gRm91bmQgbm9uLUNhbGxFeHByZXNzaW9uLidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZSA9IHJldHVybkV4cHJlc3Npb24uZ2V0KCdjYWxsZWUnKTtcbiAgICBpZiAoIWNhbGxlZS5pc0lkZW50aWZpZXIoKSB8fCBjYWxsZWUubm9kZS5uYW1lICE9PSAnZXZhbCcpIHtcbiAgICAgIHRocm93IHJldHVybkV4cHJlc3Npb24uYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgJ2V2YWwgZnVuY3Rpb24gbXVzdCByZXR1cm4gYGV2YWwoYXJndW1lbnRzWzBdKWAuIEZvdW5kIGNhbGxlZSBpcyBub3QgZXZhbC4nXG4gICAgICApO1xuICAgIH1cblxuICAgIGxldCBhcmdzID0gcmV0dXJuRXhwcmVzc2lvbi5nZXQoJ2FyZ3VtZW50cycpO1xuICAgIGlmIChhcmdzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgcmV0dXJuRXhwcmVzc2lvbi5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAnZXZhbCBmdW5jdGlvbiBtdXN0IHJldHVybiBgZXZhbChhcmd1bWVudHNbMF0pYC4gRm91bmQgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHMuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IGFyZyA9IGFyZ3NbMF07XG4gICAgaWYgKCFhcmcuaXNNZW1iZXJFeHByZXNzaW9uKCkpIHtcbiAgICAgIHRocm93IGFyZy5idWlsZENvZGVGcmFtZUVycm9yKFxuICAgICAgICAnZXZhbCBmdW5jdGlvbiBtdXN0IHJldHVybiBgZXZhbChhcmd1bWVudHNbMF0pYC4gRm91bmQgYXJndW1lbnQgaXMgbm9uLU1lbWJlckV4cHJlc3Npb24uJ1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IG9iaiA9IGFyZy5nZXQoJ29iamVjdCcpO1xuICAgIGlmICghb2JqLmlzSWRlbnRpZmllcigpIHx8IG9iai5ub2RlLm5hbWUgIT09ICdhcmd1bWVudHMnKSB7XG4gICAgICB0aHJvdyBvYmouYnVpbGRDb2RlRnJhbWVFcnJvcihcbiAgICAgICAgJ2V2YWwgZnVuY3Rpb24gbXVzdCByZXR1cm4gYGV2YWwoYXJndW1lbnRzWzBdKWAuIEZvdW5kIHdyb25nIGFyZ3VtZW50IHRvIGV2YWwuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgbGV0IHByb3AgPSBhcmcuZ2V0KCdwcm9wZXJ0eScpO1xuICAgIGlmICghcHJvcC5pc051bWVyaWNMaXRlcmFsKCkgfHwgcHJvcC5ub2RlLnZhbHVlICE9PSAwKSB7XG4gICAgICB0aHJvdyBwcm9wLmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICdldmFsIGZ1bmN0aW9uIG11c3QgcmV0dXJuIGBldmFsKGFyZ3VtZW50c1swXSlgLiBGb3VuZCB3cm9uZyBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4geyBpc0V2YWw6IHRydWUgfTtcbiAgfVxuXG4gIHBhcnNlT2JqZWN0RXhwcmVzc2lvbihcbiAgICBpbnZva2VkTmFtZTogc3RyaW5nLFxuICAgIHBhdGg6IE5vZGVQYXRoPHQuT2JqZWN0RXhwcmVzc2lvbj4sXG4gICAgc2hvdWxkUGFyc2VTY29wZSA9IGZhbHNlLFxuICAgIHNob3VsZFN1cHBvcnRSRkM5MzEgPSBmYWxzZVxuICApIHtcbiAgICBsZXQgcmVzdWx0OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiA9IHt9O1xuXG4gICAgcGF0aC5nZXQoJ3Byb3BlcnRpZXMnKS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICAgICAgbGV0IHsgbm9kZSB9ID0gcHJvcGVydHk7XG4gICAgICBpZiAodGhpcy50LmlzU3ByZWFkRWxlbWVudChub2RlKSkge1xuICAgICAgICB0aHJvdyBwcm9wZXJ0eS5idWlsZENvZGVGcmFtZUVycm9yKGAke2ludm9rZWROYW1lfSBkb2VzIG5vdCBhbGxvdyBzcHJlYWQgZWxlbWVudGApO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5jb21wdXRlZCkge1xuICAgICAgICB0aHJvdyBwcm9wZXJ0eS5idWlsZENvZGVGcmFtZUVycm9yKGAke2ludm9rZWROYW1lfSBjYW4gb25seSBhY2NlcHQgc3RhdGljIHByb3BlcnR5IG5hbWVzYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCB7IGtleSB9ID0gbm9kZTtcbiAgICAgIGlmICghdGhpcy50LmlzSWRlbnRpZmllcihrZXkpICYmICF0aGlzLnQuaXNTdHJpbmdMaXRlcmFsKGtleSkpIHtcbiAgICAgICAgdGhyb3cgcHJvcGVydHkuYnVpbGRDb2RlRnJhbWVFcnJvcihgJHtpbnZva2VkTmFtZX0gY2FuIG9ubHkgYWNjZXB0IHN0YXRpYyBwcm9wZXJ0eSBuYW1lc2ApO1xuICAgICAgfVxuXG4gICAgICBsZXQgcHJvcGVydHlOYW1lID0gbmFtZShrZXkpO1xuXG4gICAgICBpZiAoc2hvdWxkUGFyc2VTY29wZSAmJiBwcm9wZXJ0eU5hbWUgPT09ICdzY29wZScpIHtcbiAgICAgICAgcmVzdWx0LnNjb3BlID0gdGhpcy5wYXJzZVNjb3BlKGludm9rZWROYW1lLCBwcm9wZXJ0eSBhcyBOb2RlUGF0aDx0eXBlb2Ygbm9kZT4pO1xuICAgICAgfSBlbHNlIGlmIChzaG91bGRTdXBwb3J0UkZDOTMxICYmIHByb3BlcnR5TmFtZSA9PT0gJ2V2YWwnKSB7XG4gICAgICAgIHJlc3VsdC5ldmFsID0gdGhpcy5wYXJzZUV2YWwoaW52b2tlZE5hbWUsIHByb3BlcnR5IGFzIE5vZGVQYXRoPHR5cGVvZiBub2RlPik7XG4gICAgICB9IGVsc2UgaWYgKHNob3VsZFN1cHBvcnRSRkM5MzEgJiYgcHJvcGVydHlOYW1lID09PSAnY29tcG9uZW50Jykge1xuICAgICAgICByZXN1bHQuY29tcG9uZW50ID0gKHByb3BlcnR5IGFzIE5vZGVQYXRoPHR5cGVvZiBub2RlPikuZ2V0KCd2YWx1ZScpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMudC5pc09iamVjdE1ldGhvZChub2RlKSkge1xuICAgICAgICAgIHRocm93IHByb3BlcnR5LmJ1aWxkQ29kZUZyYW1lRXJyb3IoXG4gICAgICAgICAgICBgJHtpbnZva2VkTmFtZX0gZG9lcyBub3QgYWNjZXB0IGEgbWV0aG9kIGZvciAke3Byb3BlcnR5TmFtZX1gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgdmFsdWVQYXRoID0gKHByb3BlcnR5IGFzIE5vZGVQYXRoPHR5cGVvZiBub2RlPikuZ2V0KCd2YWx1ZScpO1xuICAgICAgICBpZiAoIXZhbHVlUGF0aC5pc0V4cHJlc3Npb24oKSkge1xuICAgICAgICAgIHRocm93IHZhbHVlUGF0aC5idWlsZENvZGVGcmFtZUVycm9yKGBtdXN0IGJlIGFuIGV4cHJlc3Npb25gKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcHJvcGVydHlOYW1lXSA9IHRoaXMucGFyc2VFeHByZXNzaW9uKGludm9rZWROYW1lLCB2YWx1ZVBhdGgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuYmFiZWwudHlwZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbmFtZShub2RlOiB0LlN0cmluZ0xpdGVyYWwgfCB0LklkZW50aWZpZXIpOiBzdHJpbmcge1xuICBpZiAobm9kZS50eXBlID09PSAnU3RyaW5nTGl0ZXJhbCcpIHtcbiAgICByZXR1cm4gbm9kZS52YWx1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbm9kZS5uYW1lO1xuICB9XG59XG4iXX0=