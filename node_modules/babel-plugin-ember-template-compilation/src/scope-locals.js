"use strict";
/*
  This class exists because:
   - before template compilation starts, we need to pass a `locals` array to
     ember-template-compiler
   - the JSUtils API can mutate the scope during template compilation
   - those scope mutations need to update both the original `locals` array and
     our own name mapping, keeping them in sync.
*/
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _ScopeLocals_instances, _ScopeLocals_mapping, _ScopeLocals_locals, _ScopeLocals_params, _ScopeLocals_isInJsScope;
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScopeLocals = void 0;
const hbs_utils_1 = require("./hbs-utils");
const read_only_array_1 = require("./read-only-array");
class ScopeLocals {
    constructor(params) {
        _ScopeLocals_instances.add(this);
        _ScopeLocals_mapping.set(this, {});
        _ScopeLocals_locals.set(this, []);
        _ScopeLocals_params.set(this, void 0);
        __classPrivateFieldSet(this, _ScopeLocals_params, params, "f");
    }
    get locals() {
        return (0, read_only_array_1.readOnlyArray)(__classPrivateFieldGet(this, _ScopeLocals_locals, "f"), 'The only supported way to manipulate locals is via the jsutils API\nhttps://github.com/emberjs/babel-plugin-ember-template-compilation#jsutils-manipulating-javascript-from-within-ast-transforms');
    }
    has(key) {
        return key in __classPrivateFieldGet(this, _ScopeLocals_mapping, "f");
    }
    get(key) {
        return __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[key];
    }
    isEmpty() {
        return __classPrivateFieldGet(this, _ScopeLocals_locals, "f").length === 0;
    }
    entries() {
        return Object.entries(__classPrivateFieldGet(this, _ScopeLocals_mapping, "f"));
    }
    add(hbsName, jsName) {
        __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[hbsName] = jsName !== null && jsName !== void 0 ? jsName : hbsName;
        if (!__classPrivateFieldGet(this, _ScopeLocals_locals, "f").includes(hbsName)) {
            __classPrivateFieldGet(this, _ScopeLocals_locals, "f").push(hbsName);
        }
    }
    // this AST transform discovers all possible upvars in HBS that refer to valid
    // bindings in JS, and then depending on the mode adjusts our actual scope bag
    // contents.
    crawl() {
        return (_env) => {
            let seen;
            return {
                name: 'scope-locals-crawl',
                visitor: {
                    Template: {
                        enter: () => {
                            seen = new Set();
                        },
                        exit: (_node, _path) => {
                            if (__classPrivateFieldGet(this, _ScopeLocals_params, "f").mode === 'implicit') {
                                // all hbs upvars that have matching JS bindings go into the
                                // scope
                                for (let name of seen) {
                                    if (__classPrivateFieldGet(this, _ScopeLocals_instances, "m", _ScopeLocals_isInJsScope).call(this, name, __classPrivateFieldGet(this, _ScopeLocals_params, "f").jsPath)) {
                                        this.add(name);
                                    }
                                }
                            }
                            else {
                                // in explicit form, we might prune back the preexising scope in
                                // the case where another AST transform has eliminated the use
                                // of the original binding. But we don't add anything new. The
                                // only way for new bindings to be introduced into scope is for
                                // another AST transform to explicitly call the jsutils, which
                                // calls our `add`.
                                for (let name of Object.keys(__classPrivateFieldGet(this, _ScopeLocals_mapping, "f"))) {
                                    if (!seen.has(name)) {
                                        __classPrivateFieldGet(this, _ScopeLocals_locals, "f").splice(__classPrivateFieldGet(this, _ScopeLocals_locals, "f").indexOf(name), 1);
                                        delete __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[name];
                                    }
                                }
                            }
                        },
                    },
                    PathExpression: (node, path) => {
                        if (node.head.type !== 'VarHead') {
                            return;
                        }
                        const name = node.head.name;
                        if (!(0, hbs_utils_1.astNodeHasBinding)(path, name)) {
                            seen.add(name);
                        }
                    },
                    ElementNode: (node, path) => {
                        const name = node.tag.split('.')[0];
                        if (!(0, hbs_utils_1.astNodeHasBinding)(path, name)) {
                            seen.add(name);
                        }
                    },
                },
            };
        };
    }
}
exports.ScopeLocals = ScopeLocals;
_ScopeLocals_mapping = new WeakMap(), _ScopeLocals_locals = new WeakMap(), _ScopeLocals_params = new WeakMap(), _ScopeLocals_instances = new WeakSet(), _ScopeLocals_isInJsScope = function _ScopeLocals_isInJsScope(hbsName, jsPath) {
    var _a;
    let jsName = (_a = __classPrivateFieldGet(this, _ScopeLocals_mapping, "f")[hbsName]) !== null && _a !== void 0 ? _a : hbsName;
    return ['globalThis'].includes(jsName) || jsPath.scope.getBinding(jsName);
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NvcGUtbG9jYWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsic2NvcGUtbG9jYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTs7Ozs7OztFQU9FOzs7Ozs7Ozs7Ozs7Ozs7QUFJRiwyQ0FBZ0Q7QUFDaEQsdURBQWtEO0FBcUJsRCxNQUFhLFdBQVc7SUFDdEIsWUFBWSxNQUFjOztRQUkxQiwrQkFBbUMsRUFBRSxFQUFDO1FBQ3RDLDhCQUFvQixFQUFFLEVBQUM7UUFDdkIsc0NBQWdCO1FBTGQsdUJBQUEsSUFBSSx1QkFBVyxNQUFNLE1BQUEsQ0FBQztJQUN4QixDQUFDO0lBTUQsSUFBSSxNQUFNO1FBQ1IsT0FBTyxJQUFBLCtCQUFhLEVBQ2xCLHVCQUFBLElBQUksMkJBQVEsRUFDWixtTUFBbU0sQ0FDcE0sQ0FBQztJQUNKLENBQUM7SUFFRCxHQUFHLENBQUMsR0FBVztRQUNiLE9BQU8sR0FBRyxJQUFJLHVCQUFBLElBQUksNEJBQVMsQ0FBQztJQUM5QixDQUFDO0lBRUQsR0FBRyxDQUFDLEdBQVc7UUFDYixPQUFPLHVCQUFBLElBQUksNEJBQVMsQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM1QixDQUFDO0lBRUQsT0FBTztRQUNMLE9BQU8sdUJBQUEsSUFBSSwyQkFBUSxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUM7SUFDbkMsQ0FBQztJQUVELE9BQU87UUFDTCxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsdUJBQUEsSUFBSSw0QkFBUyxDQUFDLENBQUM7SUFDdkMsQ0FBQztJQUVELEdBQUcsQ0FBQyxPQUFlLEVBQUUsTUFBZTtRQUNsQyx1QkFBQSxJQUFJLDRCQUFTLENBQUMsT0FBTyxDQUFDLEdBQUcsTUFBTSxhQUFOLE1BQU0sY0FBTixNQUFNLEdBQUksT0FBTyxDQUFDO1FBQzNDLElBQUksQ0FBQyx1QkFBQSxJQUFJLDJCQUFRLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ25DLHVCQUFBLElBQUksMkJBQVEsQ0FB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QyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gIFRoaXMgY2xhc3MgZXhpc3RzIGJlY2F1c2U6XG4gICAtIGJlZm9yZSB0ZW1wbGF0ZSBjb21waWxhdGlvbiBzdGFydHMsIHdlIG5lZWQgdG8gcGFzcyBhIGBsb2NhbHNgIGFycmF5IHRvXG4gICAgIGVtYmVyLXRlbXBsYXRlLWNvbXBpbGVyXG4gICAtIHRoZSBKU1V0aWxzIEFQSSBjYW4gbXV0YXRlIHRoZSBzY29wZSBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbiAgIC0gdGhvc2Ugc2NvcGUgbXV0YXRpb25zIG5lZWQgdG8gdXBkYXRlIGJvdGggdGhlIG9yaWdpbmFsIGBsb2NhbHNgIGFycmF5IGFuZFxuICAgICBvdXIgb3duIG5hbWUgbWFwcGluZywga2VlcGluZyB0aGVtIGluIHN5bmMuXG4qL1xuXG5pbXBvcnQgdHlwZSB7IE5vZGVQYXRoIH0gZnJvbSAnQGJhYmVsL3RyYXZlcnNlJztcbmltcG9ydCB7IEFTVFBsdWdpbkVudmlyb25tZW50LCBOb2RlVmlzaXRvciB9IGZyb20gJ0BnbGltbWVyL3N5bnRheCc7XG5pbXBvcnQgeyBhc3ROb2RlSGFzQmluZGluZyB9IGZyb20gJy4vaGJzLXV0aWxzJztcbmltcG9ydCB7IHJlYWRPbmx5QXJyYXkgfSBmcm9tICcuL3JlYWQtb25seS1hcnJheSc7XG5cbi8qXG4gICAgYG1vZGVgIHJlZmVycyB0byB0aGUgaW1wbGljaXQgYW5kIGV4cGxpY2l0IGZvcm1hdHMgZGVmaW5lZCBoZXJlOlxuXG4gICAgICBodHRwczovL2dpdGh1Yi5jb20vZW1iZXJqcy9yZmNzL2Jsb2IvOWZkNmNlYWMyNTU5YmVlMWMzM2FjZjBkNzgzNGU2NzUxMjVhNGYxNi90ZXh0LzA5MzEtdGVtcGxhdGUtY29tcGlsZXItYXBpLm1kI2V4cGxpY2l0LWZvcm1cbiAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9lbWJlcmpzL3JmY3MvYmxvYi85ZmQ2Y2VhYzI1NTliZWUxYzMzYWNmMGQ3ODM0ZTY3NTEyNWE0ZjE2L3RleHQvMDkzMS10ZW1wbGF0ZS1jb21waWxlci1hcGkubWQjaW1wbGljaXQtZm9ybVxuXG4gICAgVGhpcyBjbGFzcyBuZWVkcyB0byBrbm93IHRoZSBkaWZmZXJlbmNlIGJlY2F1c2UgaW4gaW1wbGljaXQgZm9ybWF0LCB1cHZhcnNcbiAgICBpbiBoYnMgYXJlIGF1dG9tYWdpY2FsbHkgY29ubmVjdGVkIHdpdGggb3V0ZXIgSmF2YXNjcmlwdCBiaW5kaW5ncywgYW5kIGluXG4gICAgZXhwbGljaXQgZm9ybSB0aGV5IGFyZSBub3QuXG4qL1xudHlwZSBQYXJhbXMgPVxuICB8IHtcbiAgICAgIG1vZGU6ICdleHBsaWNpdCc7XG4gICAgfVxuICB8IHtcbiAgICAgIG1vZGU6ICdpbXBsaWNpdCc7XG4gICAgICBqc1BhdGg6IE5vZGVQYXRoO1xuICAgIH07XG5cbmV4cG9ydCBjbGFzcyBTY29wZUxvY2FscyB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtczogUGFyYW1zKSB7XG4gICAgdGhpcy4jcGFyYW1zID0gcGFyYW1zO1xuICB9XG5cbiAgI21hcHBpbmc6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgI2xvY2Fsczogc3RyaW5nW10gPSBbXTtcbiAgI3BhcmFtczogUGFyYW1zO1xuXG4gIGdldCBsb2NhbHMoKSB7XG4gICAgcmV0dXJuIHJlYWRPbmx5QXJyYXkoXG4gICAgICB0aGlzLiNsb2NhbHMsXG4gICAgICAnVGhlIG9ubHkgc3VwcG9ydGVkIHdheSB0byBtYW5pcHVsYXRlIGxvY2FscyBpcyB2aWEgdGhlIGpzdXRpbHMgQVBJXFxuaHR0cHM6Ly9naXRodWIuY29tL2VtYmVyanMvYmFiZWwtcGx1Z2luLWVtYmVyLXRlbXBsYXRlLWNvbXBpbGF0aW9uI2pzdXRpbHMtbWFuaXB1bGF0aW5nLWphdmFzY3JpcHQtZnJvbS13aXRoaW4tYXN0LXRyYW5zZm9ybXMnXG4gICAgKTtcbiAgfVxuXG4gIGhhcyhrZXk6IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBrZXkgaW4gdGhpcy4jbWFwcGluZztcbiAgfVxuXG4gIGdldChrZXk6IHN0cmluZyk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuI21hcHBpbmdba2V5XTtcbiAgfVxuXG4gIGlzRW1wdHkoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuI2xvY2Fscy5sZW5ndGggPT09IDA7XG4gIH1cblxuICBlbnRyaWVzKCkge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh0aGlzLiNtYXBwaW5nKTtcbiAgfVxuXG4gIGFkZChoYnNOYW1lOiBzdHJpbmcsIGpzTmFtZT86IHN0cmluZykge1xuICAgIHRoaXMuI21hcHBpbmdbaGJzTmFtZV0gPSBqc05hbWUgPz8gaGJzTmFtZTtcbiAgICBpZiAoIXRoaXMuI2xvY2Fscy5pbmNsdWRlcyhoYnNOYW1lKSkge1xuICAgICAgdGhpcy4jbG9jYWxzLnB1c2goaGJzTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgI2lzSW5Kc1Njb3BlKGhic05hbWU6IHN0cmluZywganNQYXRoOiBOb2RlUGF0aCkge1xuICAgIGxldCBqc05hbWUgPSB0aGlzLiNtYXBwaW5nW2hic05hbWVdID8/IGhic05hbWU7XG4gICAgcmV0dXJuIFsnZ2xvYmFsVGhpcyddLmluY2x1ZGVzKGpzTmFtZSkgfHwganNQYXRoLnNjb3BlLmdldEJpbmRpbmcoanNOYW1lKTtcbiAgfVxuXG4gIC8vIHRoaXMgQVNUIHRyYW5zZm9ybSBkaXNjb3ZlcnMgYWxsIHBvc3NpYmxlIHVwdmFycyBpbiBIQlMgdGhhdCByZWZlciB0byB2YWxpZFxuICAvLyBiaW5kaW5ncyBpbiBKUywgYW5kIHRoZW4gZGVwZW5kaW5nIG9uIHRoZSBtb2RlIGFkanVzdHMgb3VyIGFjdHVhbCBzY29wZSBiYWdcbiAgLy8gY29udGVudHMuXG4gIGNyYXdsKCkge1xuICAgIHJldHVybiAoX2VudjogQVNUUGx1Z2luRW52aXJvbm1lbnQpOiB7IG5hbWU6IHN0cmluZzsgdmlzaXRvcjogTm9kZVZpc2l0b3IgfSA9PiB7XG4gICAgICBsZXQgc2VlbjogU2V0PHN0cmluZz47XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiAnc2NvcGUtbG9jYWxzLWNyYXdsJyxcbiAgICAgICAgdmlzaXRvcjoge1xuICAgICAgICAgIFRlbXBsYXRlOiB7XG4gICAgICAgICAgICBlbnRlcjogKCkgPT4ge1xuICAgICAgICAgICAgICBzZWVuID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGV4aXQ6IChfbm9kZSwgX3BhdGgpID0+IHtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuI3BhcmFtcy5tb2RlID09PSAnaW1wbGljaXQnKSB7XG4gICAgICAgICAgICAgICAgLy8gYWxsIGhicyB1cHZhcnMgdGhhdCBoYXZlIG1hdGNoaW5nIEpTIGJpbmRpbmdzIGdvIGludG8gdGhlXG4gICAgICAgICAgICAgICAgLy8gc2NvcGVcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIHNlZW4pIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc0luSnNTY29wZShuYW1lLCB0aGlzLiNwYXJhbXMuanNQYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZChuYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaW4gZXhwbGljaXQgZm9ybSwgd2UgbWlnaHQgcHJ1bmUgYmFjayB0aGUgcHJlZXhpc2luZyBzY29wZSBpblxuICAgICAgICAgICAgICAgIC8vIHRoZSBjYXNlIHdoZXJlIGFub3RoZXIgQVNUIHRyYW5zZm9ybSBoYXMgZWxpbWluYXRlZCB0aGUgdXNlXG4gICAgICAgICAgICAgICAgLy8gb2YgdGhlIG9yaWdpbmFsIGJpbmRpbmcuIEJ1dCB3ZSBkb24ndCBhZGQgYW55dGhpbmcgbmV3LiBUaGVcbiAgICAgICAgICAgICAgICAvLyBvbmx5IHdheSBmb3IgbmV3IGJpbmRpbmdzIHRvIGJlIGludHJvZHVjZWQgaW50byBzY29wZSBpcyBmb3JcbiAgICAgICAgICAgICAgICAvLyBhbm90aGVyIEFTVCB0cmFuc2Zvcm0gdG8gZXhwbGljaXRseSBjYWxsIHRoZSBqc3V0aWxzLCB3aGljaFxuICAgICAgICAgICAgICAgIC8vIGNhbGxzIG91ciBgYWRkYC5cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lIG9mIE9iamVjdC5rZXlzKHRoaXMuI21hcHBpbmcpKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoIXNlZW4uaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2xvY2Fscy5zcGxpY2UodGhpcy4jbG9jYWxzLmluZGV4T2YobmFtZSksIDEpO1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy4jbWFwcGluZ1tuYW1lXTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgfSxcbiAgICAgICAgICBQYXRoRXhwcmVzc2lvbjogKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgIGlmIChub2RlLmhlYWQudHlwZSAhPT0gJ1ZhckhlYWQnKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBub2RlLmhlYWQubmFtZTtcbiAgICAgICAgICAgIGlmICghYXN0Tm9kZUhhc0JpbmRpbmcocGF0aCwgbmFtZSkpIHtcbiAgICAgICAgICAgICAgc2Vlbi5hZGQobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcbiAgICAgICAgICBFbGVtZW50Tm9kZTogKG5vZGUsIHBhdGgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBub2RlLnRhZy5zcGxpdCgnLicpWzBdO1xuICAgICAgICAgICAgaWYgKCFhc3ROb2RlSGFzQmluZGluZyhwYXRoLCBuYW1lKSkge1xuICAgICAgICAgICAgICBzZWVuLmFkZChuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9O1xuICB9XG59XG4iXX0=